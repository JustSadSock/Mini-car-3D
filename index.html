<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport"
        content="width=device-width, height=device-height, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <link rel="icon" type="image/png" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mP8/w8AAn8B9W0YbKgAAAAASUVORK5CYII=" />
  <title>Mini Car 3D</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #0b0f16;
      touch-action: none;          /* no scroll/zoom */
      overscroll-behavior: none;   /* stop bounce */
      -webkit-user-select: none;
      user-select: none;
    }
    #wrap {
      position: fixed;
      inset: 0;
      width: 100vw;
      height: 100vh;
      overflow: hidden;
      touch-action: none;
    }
    canvas {
      display: block;
      width: 100%;
      height: 100%;
      touch-action: none;
    }

    /* Minimal UI */
    #hud {
      position: fixed;
      inset: 0;
      pointer-events: none;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      color: rgba(255,255,255,0.9);
    }
    #netStatus {
      position: absolute;
      top: calc(env(safe-area-inset-top, 0px) + 12px);
      left: calc(env(safe-area-inset-left, 0px) + 12px);
      padding: 8px 12px;
      border-radius: 12px;
      background: rgba(8, 12, 18, 0.65);
      border: 1px solid rgba(255,255,255,0.08);
      box-shadow: 0 8px 24px rgba(0,0,0,0.35);
      font-size: 12px;
      letter-spacing: 0.02em;
      pointer-events: none;
      backdrop-filter: blur(10px);
    }
    #netStatus.net-online { color: #a5ffb1; }
    #netStatus.net-offline { color: #ff9f9f; }
    /* One joystick = minimum buttons */
    #joy {
      position: absolute;
      bottom: calc(env(safe-area-inset-bottom, 0px) + 22px);
      left: 50%;
      transform: translateX(-50%);
      width: 150px;
      height: 150px;
      pointer-events: auto; /* only this accepts input */
      touch-action: none;
    }
    #joyBase {
      position: absolute;
      inset: 0;
      border-radius: 999px;
      background: rgba(255,255,255,0.06);
      border: 1px solid rgba(255,255,255,0.12);
      backdrop-filter: blur(10px);
    }
    #joyNub {
      position: absolute;
      left: 50%;
      top: 50%;
      width: 62px;
      height: 62px;
      transform: translate(-50%, -50%);
      border-radius: 999px;
      background: rgba(255,255,255,0.14);
      border: 1px solid rgba(255,255,255,0.18);
      box-shadow: 0 10px 22px rgba(0,0,0,0.35);
    }

    @media (orientation: landscape) {
      #joy {
        left: 24%;
      }
    }

  </style>
</head>

<body>
  <div id="wrap"></div>

  <div id="hud">
    <div id="netStatus" class="net-offline">Offline режим</div>
    <div id="joy" aria-label="joystick">
      <div id="joyBase"></div>
      <div id="joyNub"></div>
    </div>
  </div>

  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
        "three/examples/jsm/": "https://unpkg.com/three@0.160.0/examples/jsm/"
      }
    }
  </script>

  <script type="module">
    import * as THREE from "three";
    import { GLTFLoader } from "three/examples/jsm/loaders/GLTFLoader.js";
    import { clone as cloneSkeleton } from "three/examples/jsm/utils/SkeletonUtils.js";

    // --- Hard stop for iOS pinch / double-tap zoom antics ---
    document.addEventListener("gesturestart", (e) => e.preventDefault(), { passive: false });
    document.addEventListener("gesturechange", (e) => e.preventDefault(), { passive: false });
    document.addEventListener("gestureend", (e) => e.preventDefault(), { passive: false });
    ["touchstart","touchmove","touchend"].forEach(evt => {
      document.addEventListener(evt, (e) => e.preventDefault(), { passive: false });
    });

    const wrap = document.getElementById("wrap");
    const hud = document.getElementById("hud");
    const netStatusEl = document.getElementById("netStatus");

    const NETWORK = {
      defaultHost: "irgri.uk",
      localHost: "localhost:3000",
      mode: "offline",
      socket: null,
      id: null,
      reconnectTimer: null,
      lastSend: 0
    };

    function setNetStatus(text, online = false) {
      netStatusEl.textContent = text;
      netStatusEl.classList.toggle("net-online", online);
      netStatusEl.classList.toggle("net-offline", !online);
    }

    // --- Renderer ---
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setClearColor(0x0b0f16, 1);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.useLegacyLights = false;
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.26;
    wrap.appendChild(renderer.domElement);

    // --- Scene / Camera ---
    const scene = new THREE.Scene();
    scene.fog = new THREE.Fog(0x0b0f16, 35, 140);

    const camera = new THREE.PerspectiveCamera(
      60,
      window.innerWidth / window.innerHeight,
      0.1,
      400
    );

    // Lights (simple + cheap)
    const hemi = new THREE.HemisphereLight(0xdfe9ff, 0x1a2433, 0.9);
    scene.add(hemi);

    const sun = new THREE.DirectionalLight(0xffffff, 0.9);
    sun.position.set(12, 18, 10);
    scene.add(sun);

    // --- Ground: empty map ---
    const groundGeo = new THREE.PlaneGeometry(220, 220, 1, 1);
    const groundMat = new THREE.MeshStandardMaterial({
      color: 0x232a35,
      roughness: 1.0,
      metalness: 0.0
    });
    const ground = new THREE.Mesh(groundGeo, groundMat);
    ground.rotation.x = -Math.PI / 2;
    ground.position.y = 0;
    ground.receiveShadow = true;
    scene.add(ground);

    const grid = new THREE.GridHelper(220, 44, 0x3a4454, 0x2a3342);
    grid.material.transparent = true;
    grid.material.opacity = 0.25;
    grid.position.y = 0.01;
    scene.add(grid);

    function makeNoiseNormalTexture(size = 128, spread = 6) {
      const data = new Uint8Array(size * size * 3);
      for (let i = 0; i < size * size; i++) {
        const base = 128;
        const nx = base + Math.floor((Math.random() * 2 - 1) * spread);
        const ny = base + Math.floor((Math.random() * 2 - 1) * spread);
        const softness = 255 - Math.min(48, Math.abs(nx - base) * 2 + Math.abs(ny - base) * 2);
        data[i * 3 + 0] = THREE.MathUtils.clamp(nx, 0, 255);
        data[i * 3 + 1] = THREE.MathUtils.clamp(ny, 0, 255);
        data[i * 3 + 2] = THREE.MathUtils.clamp(softness, 0, 255);
      }
      const tex = new THREE.DataTexture(data, size, size, THREE.RGBFormat);
      tex.needsUpdate = true;
      tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
      tex.minFilter = THREE.LinearMipMapLinearFilter;
      tex.magFilter = THREE.LinearFilter;
      tex.anisotropy = 4;
      return tex;
    }

    function makeRadialGlowTexture(size = 256, color = "#ff2b3a") {
      const canvas = document.createElement("canvas");
      canvas.width = canvas.height = size;
      const ctx = canvas.getContext("2d");
      const radius = size / 2;
      const grad = ctx.createRadialGradient(radius, radius, radius * 0.1, radius, radius, radius * 0.95);
      const col = new THREE.Color(color);
      const solid = `rgba(${Math.round(col.r * 255)},${Math.round(col.g * 255)},${Math.round(col.b * 255)},`;
      grad.addColorStop(0, `${solid}0.9)`);
      grad.addColorStop(0.35, `${solid}0.65)`);
      grad.addColorStop(0.75, `${solid}0.22)`);
      grad.addColorStop(1, `${solid}0)`);
      ctx.fillStyle = grad;
      ctx.fillRect(0, 0, size, size);

      const tex = new THREE.CanvasTexture(canvas);
      tex.colorSpace = THREE.SRGBColorSpace;
      tex.minFilter = THREE.LinearMipMapLinearFilter;
      tex.magFilter = THREE.LinearFilter;
      tex.anisotropy = 4;
      return tex;
    }

    function makeHeadlightCookieTexture(size = 256) {
      const canvas = document.createElement("canvas");
      canvas.width = canvas.height = size;
      const ctx = canvas.getContext("2d");
      ctx.clearRect(0, 0, size, size);

      // Soft elliptical glow
      ctx.save();
      ctx.translate(size / 2, size * 0.6);
      ctx.scale(1.16, 0.82);
      const radius = size * 0.48;
      const grad = ctx.createRadialGradient(0, 0, radius * 0.12, 0, 0, radius);
      grad.addColorStop(0.0, "rgba(255,255,255,0.95)");
      grad.addColorStop(0.3, "rgba(255,255,255,0.6)");
      grad.addColorStop(0.64, "rgba(255,255,255,0.28)");
      grad.addColorStop(1.0, "rgba(255,255,255,0)");
      ctx.fillStyle = grad;
      ctx.beginPath();
      ctx.arc(0, 0, radius, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();

      // Slight directional streaks
      ctx.save();
      ctx.translate(size / 2, size * 0.52);
      ctx.rotate(-Math.PI / 16);
      const streakGrad = ctx.createLinearGradient(-size * 0.28, 0, size * 0.32, 0);
      streakGrad.addColorStop(0, "rgba(255,255,255,0)");
      streakGrad.addColorStop(0.5, "rgba(255,255,255,0.08)");
      streakGrad.addColorStop(1, "rgba(255,255,255,0)");
      ctx.fillStyle = streakGrad;
      ctx.fillRect(-size * 0.38, -size * 0.23, size * 0.74, size * 0.46);
      ctx.restore();

      // Low-beam cutoff (top slice removed)
      ctx.globalCompositeOperation = "destination-out";
      const cutHeight = size * 0.41;
      const cutGrad = ctx.createLinearGradient(0, 0, 0, cutHeight);
      cutGrad.addColorStop(0, "rgba(0,0,0,1)");
      cutGrad.addColorStop(1, "rgba(0,0,0,0)");
      ctx.fillStyle = cutGrad;
      ctx.fillRect(0, 0, size, cutHeight);
      ctx.globalCompositeOperation = "source-over";

      const tex = new THREE.CanvasTexture(canvas);
      tex.minFilter = THREE.LinearFilter;
      tex.magFilter = THREE.LinearFilter;
      tex.wrapS = tex.wrapT = THREE.ClampToEdgeWrapping;
      tex.needsUpdate = true;
      return tex;
    }

    function makeBeamAlphaTexture(width = 32, height = 128) {
      const canvas = document.createElement("canvas");
      canvas.width = width;
      canvas.height = height;
      const ctx = canvas.getContext("2d");
      const grad = ctx.createLinearGradient(0, 0, 0, height);
      grad.addColorStop(0, "rgba(255,255,255,0.35)");
      grad.addColorStop(0.55, "rgba(255,255,255,0.16)");
      grad.addColorStop(1, "rgba(255,255,255,0)");
      ctx.fillStyle = grad;
      ctx.fillRect(0, 0, width, height);
      const tex = new THREE.CanvasTexture(canvas);
      tex.wrapS = tex.wrapT = THREE.ClampToEdgeWrapping;
      tex.minFilter = THREE.LinearFilter;
      tex.magFilter = THREE.LinearFilter;
      tex.needsUpdate = true;
      return tex;
    }

    const headlightCookie = makeHeadlightCookieTexture();
    const beamAlphaTex = makeBeamAlphaTexture();
    const HEADLIGHT_POWER = 1850;

    function attachHeadlights(car) {
      const box = new THREE.Box3().setFromObject(car);
      const size = box.getSize(new THREE.Vector3());
      const center = box.getCenter(new THREE.Vector3());

      const headlightHeight = center.y + size.y * 0.16;
      const noseZ = box.max.z;
      const offsetX = size.x * 0.22;

      const target = new THREE.Object3D();
      target.position.set(0, headlightHeight + size.y * 0.12, noseZ + size.z * 0.68);
      car.add(target);

      const createBeam = (distance, angle) => {
        const radius = Math.tan(angle) * distance;
        const beamGeo = new THREE.ConeGeometry(radius, distance, 14, 1, true);
        // Orient so the cone's -Z faces forward (matching lookAt behavior)
        beamGeo.rotateX(-Math.PI / 2);
        const beamMat = new THREE.MeshBasicMaterial({
          color: 0xc8d8ff,
          transparent: true,
          opacity: 0.05,
          blending: THREE.AdditiveBlending,
          depthWrite: false,
          side: THREE.DoubleSide,
          alphaMap: beamAlphaTex
        });
        const mesh = new THREE.Mesh(beamGeo, beamMat);
        mesh.visible = false; // Only visible in heavy fog; keep disabled for clear air
        return mesh;
      };

      const makeLight = (x) => {
        const spot = new THREE.SpotLight(0xffffff, 0, 54, THREE.MathUtils.degToRad(15), 0.6, 2);
        spot.position.set(x, headlightHeight, noseZ - size.z * 0.015);
        spot.target = target;
        spot.power = HEADLIGHT_POWER;
        spot.map = headlightCookie;
        spot.castShadow = false;
        spot.shadow.mapSize.set(512, 512);
        spot.shadow.bias = -0.0002;
        spot.shadow.camera.near = 0.2;
        spot.shadow.camera.far = 80;
        car.add(spot);
        return spot;
      };

      const left = makeLight(-offsetX);
      const right = makeLight(offsetX);
      left.castShadow = true;

      const beams = {
        left: createBeam(left.distance || 50, left.angle),
        right: createBeam(right.distance || 50, right.angle)
      };
      beams.left.position.copy(left.position);
      beams.right.position.copy(right.position);
      const worldTarget = new THREE.Vector3();
      target.getWorldPosition(worldTarget);
      beams.left.lookAt(worldTarget);
      beams.right.lookAt(worldTarget);
      car.add(beams.left, beams.right);

      return { left, right, target, beams };
    }

    function attachRearLights(car, existingTailMeshes = [], tailLightMaterials = []) {
      const box = new THREE.Box3().setFromObject(car);
      const size = box.getSize(new THREE.Vector3());
      const center = box.getCenter(new THREE.Vector3());
      const backZ = box.min.z - size.z * 0.015;
      const height = center.y + size.y * 0.12;
      const offsetX = size.x * 0.24;

      const dimIntensity = 1.0;
      const brakeBoost = 3.2;
      const reverseBoost = 2.8;

      const makeRedMaterial = () => new THREE.MeshStandardMaterial({
        color: 0x150606,
        emissive: 0xff2b2b,
        emissiveIntensity: 0,
        roughness: 0.4,
        metalness: 0.05,
        transparent: true,
        opacity: 0.98,
        depthWrite: false
      });

      const makeWhiteMaterial = () => new THREE.MeshStandardMaterial({
        color: 0x0a0a0a,
        emissive: 0xffffff,
        emissiveIntensity: 0,
        roughness: 0.5,
        metalness: 0.08,
        transparent: true,
        opacity: 0.96,
        depthWrite: false
      });

      const makePlate = (isReverse = false) => {
        const w = size.x * 0.18;
        const h = size.y * 0.1;
        const geo = new THREE.PlaneGeometry(w, h);
        const mat = isReverse ? makeWhiteMaterial() : makeRedMaterial();
        const mesh = new THREE.Mesh(geo, mat);
        mesh.position.set(0, height, backZ);
        mesh.castShadow = false;
        mesh.receiveShadow = false;
        return mesh;
      };

      function assignExistingMeshes(meshes, fallbackCreator) {
        const sorted = meshes
          .map((m) => ({ mesh: m, x: m.getWorldPosition(new THREE.Vector3()).x }))
          .sort((a, b) => a.x - b.x);
        if (sorted.length >= 2) {
          const left = sorted[0].mesh;
          const right = sorted[sorted.length - 1].mesh;
          if (!left.material?.isMeshStandardMaterial) left.material = fallbackCreator(false).material.clone();
          if (!right.material?.isMeshStandardMaterial) right.material = fallbackCreator(false).material.clone();
          return { left, right };
        }
        return { left: fallbackCreator(false), right: fallbackCreator(false) };
      }

      const { left: tailLeft, right: tailRight } = assignExistingMeshes(existingTailMeshes, makePlate);
      tailLeft.position.set(-offsetX, height, backZ);
      tailRight.position.set(offsetX, height, backZ);
      tailLeft.material = tailLeft.material.clone();
      tailRight.material = tailRight.material.clone();
      car.add(tailLeft, tailRight);

      const revLeft = makePlate(true);
      const revRight = makePlate(true);
      revLeft.scale.set(0.7, 0.8, 1);
      revRight.scale.set(0.7, 0.8, 1);
      revLeft.position.set(-offsetX * 0.7, height - size.y * 0.04, backZ + size.z * 0.01);
      revRight.position.set(offsetX * 0.7, height - size.y * 0.04, backZ + size.z * 0.01);
      car.add(revLeft, revRight);

      const makePointLight = (color) => {
        const light = new THREE.PointLight(color, 0, 8, 2);
        light.castShadow = false;
        light.power = 0;
        light.position.set(0, height, backZ + size.z * 0.06);
        return light;
      };

      const brakeLightL = makePointLight(0xff2b2b);
      const brakeLightR = makePointLight(0xff2b2b);
      brakeLightL.distance = brakeLightR.distance = 8.5;
      brakeLightL.power = brakeLightR.power = 0;
      brakeLightL.position.x = -offsetX * 0.9;
      brakeLightR.position.x = offsetX * 0.9;

      const reverseLightL = makePointLight(0xffffff);
      const reverseLightR = makePointLight(0xffffff);
      reverseLightL.distance = reverseLightR.distance = 10;
      reverseLightL.power = reverseLightR.power = 0;
      reverseLightL.position.x = -offsetX * 0.75;
      reverseLightR.position.x = offsetX * 0.75;

      car.add(brakeLightL, brakeLightR, reverseLightL, reverseLightR);

      return {
        leftMesh: tailLeft,
        rightMesh: tailRight,
        reverseLeftMesh: revLeft,
        reverseRightMesh: revRight,
        brakeLightL,
        brakeLightR,
        reverseLightL,
        reverseLightR,
        tailMaterials: tailLightMaterials,
        brakeFactor: 0,
        reverseFactor: 0,
        dimIntensity,
        brakeBoost,
        reverseBoost,
        prevSpeed: 0,
        lightsOn: true
      };
    }

    function updateRearLights(rig, dt, speed, targetSpeed, throttle, lightsOn = true) {
      if (!rig) return;
      const safeDt = Math.max(dt, 0.0001);
      const accel = (speed - rig.prevSpeed) / safeDt;
      rig.prevSpeed = speed;

      const isReversing = speed < -0.4 || (targetSpeed < -0.2 && speed < -0.05);
      const isBraking = (
        speed > 0.6 && accel < -1.2
      ) || (speed > 0.4 && throttle < -0.2);

      const smoothing = 1 - Math.pow(0.12, safeDt);
      rig.brakeFactor = THREE.MathUtils.lerp(rig.brakeFactor, isBraking ? 1 : 0, smoothing);
      rig.reverseFactor = THREE.MathUtils.lerp(rig.reverseFactor, isReversing ? 1 : 0, smoothing);

      rig.lightsOn = lightsOn;
      const dim = lightsOn ? rig.dimIntensity : 0;
      const brakeIntensity = dim + rig.brakeFactor * rig.brakeBoost;
      const reverseIntensity = rig.reverseFactor * rig.reverseBoost;

      [rig.leftMesh, rig.rightMesh].forEach((mesh) => {
        if (mesh?.material?.emissiveIntensity !== undefined) {
          mesh.material.emissiveIntensity = brakeIntensity;
        }
        if (mesh) mesh.visible = lightsOn || rig.brakeFactor > 0.02;
      });

      rig.tailMaterials?.forEach((mat) => {
        if (mat?.emissiveIntensity !== undefined) {
          mat.emissiveIntensity = brakeIntensity;
        }
        if (mat) mat.visible = lightsOn || rig.brakeFactor > 0.02;
      });

      [rig.reverseLeftMesh, rig.reverseRightMesh].forEach((mesh) => {
        if (mesh?.material?.emissiveIntensity !== undefined) {
          mesh.material.emissiveIntensity = reverseIntensity;
        }
        if (mesh) mesh.visible = reverseIntensity > 0.02;
      });

      const brakePower = rig.brakeFactor * 90 + (lightsOn ? 25 : 0);
      rig.brakeLightL.power = brakePower;
      rig.brakeLightR.power = brakePower;

      const reversePower = rig.reverseFactor * 120;
      rig.reverseLightL.power = reversePower;
      rig.reverseLightR.power = reversePower;
      rig.reverseLightL.visible = rig.reverseLightR.visible = reversePower > 1;
    }

    // --- Car (GLB model) ---
    const gltfLoader = new GLTFLoader();
    const carModelPromise = loadCarModel();

    let car = null;

    function loadCarModel() {
      return gltfLoader.loadAsync("models/normalcar1.glb").then((gltf) => gltf.scene);
    }

    let loggedCarStructure = false;
    function logCarStructure(root) {
      if (loggedCarStructure) return;
      loggedCarStructure = true;
      const lines = [];
      root.traverse((child) => {
        const mats = [];
        const material = child.material;
        if (Array.isArray(material)) {
          material.forEach((m) => m && mats.push(m.name || "(mat)"));
        } else if (material) {
          mats.push(material.name || "(mat)");
        }
        lines.push(`${child.name || child.type}${mats.length ? ` [${mats.join(", ")}]` : ""}`);
      });
      console.groupCollapsed("[CarModel] Scene graph");
      lines.forEach((l) => console.log(l));
      console.groupEnd();
    }

    function cloneMaterials(obj) {
      obj.traverse((child) => {
        if (!child.isMesh || !child.material) return;
        if (Array.isArray(child.material)) {
          child.material = child.material.map((mat) => mat?.clone?.() || mat);
        } else {
          child.material = child.material.clone();
        }
      });
    }

    function findMaterials(root, match) {
      const result = new Set();
      root.traverse((child) => {
        if (!child.isMesh || !child.material) return;
        const mats = Array.isArray(child.material) ? child.material : [child.material];
        mats.forEach((mat) => {
          const name = (mat?.name || child.name || "").toLowerCase();
          if (match(name)) result.add(mat);
        });
      });
      return Array.from(result);
    }

    function findWheelCandidates(root) {
      const wheels = [];
      root.traverse((child) => {
        const name = (child.name || "").toLowerCase();
        if (name.includes("wheel") || name.includes("tyre") || name.includes("tire")) {
          wheels.push(child);
        }
      });
      return wheels;
    }

    function categorizeWheels(root) {
      const wheelNodes = findWheelCandidates(root);
      if (wheelNodes.length === 0) {
        logCarStructure(root);
        return { wheelRig: [], radius: 0.3 };
      }

      root.updateMatrixWorld(true);
      const temp = new THREE.Vector3();
      const wheels = wheelNodes.map((mesh) => ({
        mesh,
        position: mesh.getWorldPosition(temp.clone()),
      }));

      const sorted = wheels.sort((a, b) => b.position.z - a.position.z);
      const front = new Set(sorted.slice(0, 2).map(({ mesh }) => mesh));

      const wheelRig = sorted.map(({ mesh }) => {
        const isFront = front.has(mesh);
        const parent = mesh.parent || mesh;
        const parentName = (parent.name || "").toLowerCase();
        const pivot = isFront && parent !== root && (parentName.includes("pivot") || parentName.includes("steer"))
          ? parent
          : mesh;
        return {
          mesh,
          pivot,
          steerable: isFront,
          baseQuaternion: mesh.quaternion.clone(),
          pivotBaseQuaternion: pivot.quaternion.clone(),
          angle: 0,
        };
      });

      const radius = (() => {
        const box = new THREE.Box3().setFromObject(wheels[0].mesh);
        return Math.max(0.15, (box.max.y - box.min.y) / 2);
      })();

      return { wheelRig, radius };
    }

    function collectBodyMaterials(root) {
      const blacklist = ["light", "lamp", "glass", "window", "wind", "screen", "plate", "license", "tyre", "tire", "wheel", "brake", "head", "tail", "led", "signal", "mirror"];
      const bluish = (color) => color && color.b > color.g * 0.9 && color.b > color.r * 1.15 && color.b > 0.28;
      const rawCandidates = findMaterials(root, (name) =>
        (name.includes("body") || name.includes("paint") || name.includes("car")) &&
        !blacklist.some((bad) => name.includes(bad))
      );

      const filtered = rawCandidates.filter((mat) => {
        const name = (mat?.name || "").toLowerCase();
        if (blacklist.some((bad) => name.includes(bad))) return false;
        return bluish(mat.color);
      });

      if (filtered.length > 0) return filtered;

      const fallback = [];
      root.traverse((child) => {
        if (
          child.isMesh &&
          child.material &&
          !Array.isArray(child.material) &&
          child.material.color &&
          !blacklist.some((bad) => (child.name || "").toLowerCase().includes(bad)) &&
          !blacklist.some((bad) => (child.material.name || "").toLowerCase().includes(bad)) &&
          bluish(child.material.color)
        ) {
          fallback.push(child.material);
        }
      });
      if (fallback.length === 0) {
        logCarStructure(root);
      }
      return fallback;
    }

    function collectLightMaterials(root) {
      const headlights = new Set(
        findMaterials(root, (name) =>
          name.includes("head") || name.includes("front") || name.includes("lamp") || name.includes("light")
        )
      );
      const tailLights = new Set(
        findMaterials(root, (name) =>
          name.includes("tail") || name.includes("rear") || name.includes("back") || name.includes("brake") || name.includes("light")
        )
      );

      const normalizeLightMaterial = (mat, fallbackColor, minIntensity) => {
        if (!mat) return;
        const color = new THREE.Color(fallbackColor);
        if (mat.color && (mat.color.r + mat.color.g + mat.color.b) < 0.05) mat.color.set(color);
        if (mat.emissive) {
          mat.emissive.set(color);
        }
        if (typeof mat.emissiveIntensity !== "number" || mat.emissiveIntensity < minIntensity) {
          mat.emissiveIntensity = minIntensity;
        }
      };

      const ensureColorMatches = (mat, predicate, bucket, fallbackColor, minIntensity) => {
        const c = mat.emissive || mat.color;
        if (!c) return;
        if (predicate(c)) {
          bucket.add(mat);
          normalizeLightMaterial(mat, fallbackColor, minIntensity);
        }
      };

      root.traverse((child) => {
        if (!child.isMesh || !child.material) return;
        const mats = Array.isArray(child.material) ? child.material : [child.material];
        mats.forEach((mat) => {
          ensureColorMatches(
            mat,
            (c) => c.r > 0.65 && c.g > 0.2 && c.b < 0.2 && c.r > c.g,
            headlights,
            0xffffff,
            1.4
          );
          ensureColorMatches(
            mat,
            (c) => c.r > 0.55 && c.g < 0.25 && c.b < 0.25 && c.r > c.g * 1.6,
            tailLights,
            0xff2b2b,
            0.8
          );
        });
      });

      if (headlights.size === 0 || tailLights.size === 0) {
        logCarStructure(root);
      }

      headlights.forEach((mat) => normalizeLightMaterial(mat, 0xffffff, 1.4));
      tailLights.forEach((mat) => normalizeLightMaterial(mat, 0xff2b2b, 0.8));

      return { headlights: Array.from(headlights), tailLights: Array.from(tailLights) };
    }

    const wheelRollAxis = new THREE.Vector3(1, 0, 0);
    const wheelSteerAxis = new THREE.Vector3(0, 1, 0);
    const tempRollQuat = new THREE.Quaternion();
    const tempSteerQuat = new THREE.Quaternion();

    function applyWheelPose(car, steerAngle, rollDelta) {
      const rig = car.userData.wheelRig;
      if (!rig) return;
      tempSteerQuat.setFromAxisAngle(wheelSteerAxis, steerAngle || 0);
      const delta = typeof rollDelta === "number" ? rollDelta : 0;
      rig.forEach((wheel) => {
        wheel.angle += delta;
        tempRollQuat.setFromAxisAngle(wheelRollAxis, wheel.angle);
        if (wheel.steerable) {
          if (wheel.pivot && wheel.pivot !== wheel.mesh) {
            wheel.pivot.quaternion.copy(wheel.pivotBaseQuaternion).multiply(tempSteerQuat);
            wheel.mesh.quaternion.copy(wheel.baseQuaternion).multiply(tempRollQuat);
          } else {
            wheel.mesh.quaternion.copy(wheel.baseQuaternion).multiply(tempSteerQuat).multiply(tempRollQuat);
          }
        } else {
          wheel.mesh.quaternion.copy(wheel.baseQuaternion).multiply(tempRollQuat);
        }
      });
    }

    async function makeCar() {
      const baseScene = await carModelPromise;
      const car = cloneSkeleton(baseScene);
      cloneMaterials(car);

      car.traverse((child) => {
        if (child.isMesh) {
          child.castShadow = true;
        }
      });

      const { wheelRig, radius } = categorizeWheels(car);
      const { headlights, tailLights } = collectLightMaterials(car);
      const bodyMaterials = collectBodyMaterials(car);

      const headlightIntensities = headlights.map((m) =>
        typeof m.emissiveIntensity === "number" ? m.emissiveIntensity : 1.25
      );

      car.userData.wheelRig = wheelRig;
      car.userData.wheelRadius = radius;
      car.userData.lightsOn = true;
      car.userData.brakeActive = false;

      car.userData.setPlayerColor = (color) => {
        bodyMaterials.forEach((mat) => {
          if (mat?.color) mat.color.set(color);
        });
      };

      car.userData.setLights = (on) => {
        car.userData.lightsOn = Boolean(on);
        car.userData.applyLights?.(car.userData.brakeActive);
      };

      car.userData.applyLights = (brake = false) => {
        headlights.forEach((mat, i) => {
          if (typeof mat.emissiveIntensity === "number") {
            mat.emissiveIntensity = car.userData.lightsOn ? headlightIntensities[i] : 0.0;
          }
          mat.visible = car.userData.lightsOn;
        });
        const rig = car.userData.headlights;
        if (rig?.left && rig?.right) {
          const on = car.userData.lightsOn;
          rig.left.visible = on;
          rig.right.visible = on;
          rig.left.power = on ? HEADLIGHT_POWER : 0;
          rig.right.power = on ? HEADLIGHT_POWER : 0;
          if (rig.target) rig.target.visible = on;
          if (rig.beams) {
            rig.beams.left.visible = false;
            rig.beams.right.visible = false;
          }
        }

        if (car.userData.rearLights) {
          car.userData.rearLights.lightsOn = car.userData.lightsOn;
        }

      };

      car.userData.headlights = attachHeadlights(car);
      car.userData.rearLights = attachRearLights(car, [], tailLights);
      car.userData.applyLights(false);

      return car;
    }

    async function setupPlayerCar() {
      car = await makeCar();
      scene.add(car);
      ensureLocalColor();
    }


    // --- Multiplayer (online/offline aware) ---
    const remotePlayers = new Map();

    const PLAYER_COLORS = [
      "#ff6b35", // orange
      "#ffd166", // yellow
      "#06d6a0", // green
      "#5e60ce", // purple
      "#f72585", // magenta
      "#2ec4b6", // teal
      "#f4a261", // tan/orange
      "#a0d911", // lime
    ];

    function colorIndexFromId(id) {
      const text = id || "local";
      let hash = 0;
      for (let i = 0; i < text.length; i++) {
        hash = (hash * 31 + text.charCodeAt(i)) >>> 0;
      }
      return hash % PLAYER_COLORS.length;
    }

    function colorizeCar(mesh, idForColor) {
      const hex = PLAYER_COLORS[colorIndexFromId(idForColor)];
      const color = new THREE.Color(hex);
      mesh.userData.playerColor = hex;
      mesh.userData.setPlayerColor?.(color);
    }

    function ensureLocalColor() {
      if (!car) return;
      const colorId = NETWORK.id || "local";
      if (car.userData.assignedColorId === colorId) return;
      colorizeCar(car, colorId);
      car.userData.assignedColorId = colorId;
    }

    async function spawnRemotePlayer(id, snapshot) {
      if (remotePlayers.has(id)) return;
      const placeholder = { mesh: null, target: null, loading: true };
      remotePlayers.set(id, placeholder);
      const ghost = await makeCar();
      colorizeCar(ghost, id);
      ghost.userData.isRemote = true;
      ghost.userData.applyLights?.(false);
      scene.add(ghost);
      placeholder.mesh = ghost;
      placeholder.loading = false;
      applyRemoteState(id, snapshot || { p: [0, 0, 0], y: 0, s: 0 });
    }

    function removeRemotePlayer(id) {
      const player = remotePlayers.get(id);
      if (!player) return;
      if (player.mesh) {
        scene.remove(player.mesh);
        player.mesh.traverse((child) => {
          if (child.geometry) child.geometry.dispose?.();
          if (child.material) child.material.dispose?.();
        });
      }
      remotePlayers.delete(id);
    }

    function applyRemoteState(id, state) {
      const player = remotePlayers.get(id);
      if (!player) return;
      const target = {
        position: new THREE.Vector3(state.p?.[0] || 0, state.p?.[1] || 0, state.p?.[2] || 0),
        yaw: state.y || 0,
        speed: state.s || 0,
        steer: state.st || 0,
        brake: Boolean(state.b),
        received: performance.now()
      };
      player.target = target;
    }

    function updateRemotePlayers(dt) {
      const follow = 1 - Math.pow(0.0015, dt);
      for (const player of remotePlayers.values()) {
        if (!player.mesh || !player.target) continue;
        player.mesh.position.lerp(player.target.position, follow);
        const currentYaw = player.mesh.rotation.y;
        const deltaYaw = ((player.target.yaw - currentYaw + Math.PI * 3) % (Math.PI * 2)) - Math.PI;
        player.mesh.rotation.y = currentYaw + deltaYaw * follow;

        const rollDelta = (player.target.speed / (player.mesh.userData.wheelRadius || 1)) * dt;
        applyWheelPose(player.mesh, player.target.steer || 0, rollDelta);
        player.mesh.userData.brakeActive = Boolean(player.target.brake);
        player.mesh.userData.applyLights?.(player.mesh.userData.brakeActive);
        if (player.mesh.userData.rearLights) {
          const throttleHint = player.target.speed < -0.1 ? -1 : player.mesh.userData.brakeActive ? -1 : 0.2;
          updateRearLights(
            player.mesh.userData.rearLights,
            dt,
            player.target.speed,
            player.target.speed,
            throttleHint,
            player.mesh.userData.lightsOn ?? true
          );
        }
      }
    }

    function resolveServerHost() {
      const host = location.hostname;
      if (host === "localhost" || host === "127.0.0.1") return NETWORK.localHost;
      if (!host || host === "") return NETWORK.defaultHost;
      return NETWORK.defaultHost;
    }

    async function checkServerAvailability(host, timeoutMs = 1800) {
      const controller = new AbortController();
      const timer = setTimeout(() => controller.abort(), timeoutMs);
      const protocol = host.includes("localhost") || host.includes("127.0.0.1") ? "http" : "https";
      try {
        const res = await fetch(`${protocol}://${host}/health`, {
          signal: controller.signal,
          cache: "no-store"
        });
        return res.ok;
      } catch (err) {
        return false;
      } finally {
        clearTimeout(timer);
      }
    }

    function cleanSocket() {
      if (NETWORK.socket) {
        NETWORK.socket.close();
        NETWORK.socket = null;
      }
    }

    function scheduleReconnect() {
      if (NETWORK.reconnectTimer) return;
      NETWORK.reconnectTimer = setTimeout(() => {
        NETWORK.reconnectTimer = null;
        initNetwork();
      }, 2500);
    }

    function sendStateSnapshot() {
      if (!NETWORK.socket || NETWORK.socket.readyState !== WebSocket.OPEN) return;
      if (!car) return;
      const now = performance.now();
      if (now - NETWORK.lastSend < 50) return; // ~20 Hz
      NETWORK.lastSend = now;
      const payload = {
        type: "state",
        state: {
          p: [Number(car.position.x.toFixed(3)), Number(car.position.y.toFixed(3)), Number(car.position.z.toFixed(3))],
          y: Number(state.yaw.toFixed(4)),
          s: Number(state.speed.toFixed(3)),
          st: Number(state.steer.toFixed(4)),
          b: Boolean(state.brakeActive)
        }
      };
      NETWORK.socket.send(JSON.stringify(payload));
    }

    function handleMessage(evt) {
      let data;
      try {
        data = JSON.parse(evt.data);
      } catch (err) {
        return;
      }

      if (data.type === "hello") {
        NETWORK.id = data.id;
        setNetStatus(`Online: ${resolveServerHost()}`, true);
        ensureLocalColor();
        if (Array.isArray(data.players)) {
          data.players.forEach((p) => {
            if (!remotePlayers.has(p.id)) spawnRemotePlayer(p.id, p.state).catch((err) => console.warn("Remote spawn failed", err));
            else applyRemoteState(p.id, p.state);
          });
        }
        sendStateSnapshot();
      } else if (data.type === "state" && data.id && data.id !== NETWORK.id) {
        if (!remotePlayers.has(data.id)) spawnRemotePlayer(data.id, data.state).catch((err) => console.warn("Remote spawn failed", err));
        else applyRemoteState(data.id, data.state);
      } else if (data.type === "player-left" && data.id) {
        removeRemotePlayer(data.id);
      } else if (data.type === "player-joined" && data.id && data.id !== NETWORK.id) {
        if (!remotePlayers.has(data.id)) spawnRemotePlayer(data.id, { p: [0, 0, 0], y: 0, s: 0 }).catch((err) => console.warn("Remote spawn failed", err));
      }
    }

    async function initNetwork() {
      cleanSocket();
      const host = resolveServerHost();
      const available = await checkServerAvailability(host);
      if (!available) {
        NETWORK.mode = "offline";
        setNetStatus("Offline режим (сервер недоступен)", false);
        scheduleReconnect();
        return;
      }

      const protocol = host.includes("localhost") || host.includes("127.0.0.1") ? "ws" : "wss";
      const ws = new WebSocket(`${protocol}://${host}/ws`);
      ws.addEventListener("open", () => {
        NETWORK.socket = ws;
        NETWORK.mode = "online";
        NETWORK.lastSend = 0;
        setNetStatus(`Online: ${host}`, true);
        sendStateSnapshot();
      });
      ws.addEventListener("message", handleMessage);
      ws.addEventListener("close", () => {
        NETWORK.mode = "offline";
        setNetStatus("Offline режим (нет соединения)", false);
        NETWORK.socket = null;
        scheduleReconnect();
      });
      ws.addEventListener("error", () => {
        setNetStatus("Offline режим (ошибка связи)", false);
      });
    }

    // --- Input: single joystick + keyboard fallback ---
    const joy = document.getElementById("joy");
    const nub = document.getElementById("joyNub");
    const isCoarsePointer = window.matchMedia("(pointer: coarse)").matches;
    if (!isCoarsePointer) {
      joy.style.display = "none";
    }

    let joyActive = false;
    let joyPointerId = null;
    let joyX = 0;  // -1..1
    let joyY = 0;  // -1..1

    function setNub(dx, dy) {
      nub.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
    }

    function handleJoyEvent(e) {
      e.preventDefault();
      const rect = joy.getBoundingClientRect();
      const cx = rect.left + rect.width / 2;
      const cy = rect.top + rect.height / 2;
      const radius = rect.width * 0.36; // nub travel

      const px = e.clientX;
      const py = e.clientY;

      let dx = px - cx;
      let dy = py - cy;

      const len = Math.hypot(dx, dy);
      if (len > radius) {
        dx = (dx / len) * radius;
        dy = (dy / len) * radius;
      }

      setNub(dx, dy);

      // Normalize to -1..1. Up on screen = forward throttle.
      joyX = dx / radius;
      joyY = -dy / radius;

      // Deadzone (so it doesn't drift)
      const dz = 0.08;
      if (Math.abs(joyX) < dz) joyX = 0;
      if (Math.abs(joyY) < dz) joyY = 0;
    }

    joy.addEventListener("pointerdown", (e) => {
      joyActive = true;
      joyPointerId = e.pointerId;
      joy.setPointerCapture(joyPointerId);
      handleJoyEvent(e);
    }, { passive: false });

    joy.addEventListener("pointermove", (e) => {
      if (!joyActive || e.pointerId !== joyPointerId) return;
      handleJoyEvent(e);
    }, { passive: false });

    function releaseJoy() {
      joyActive = false;
      joyPointerId = null;
      joyX = 0;
      joyY = 0;
      setNub(0, 0);
    }

    joy.addEventListener("pointerup", (e) => {
      if (e.pointerId !== joyPointerId) return;
      releaseJoy();
    }, { passive: false });

    joy.addEventListener("pointercancel", releaseJoy, { passive: false });

    let lastTapTime = 0;
    window.addEventListener("touchend", (e) => {
      const now = performance.now();
      if (now - lastTapTime < 280) {
        if (car?.userData?.setLights) {
          car.userData.setLights(!car.userData.lightsOn);
        }
      }
      lastTapTime = now;
    }, { passive: false });

    // Keyboard fallback (PC)
    const keys = new Set();
    window.addEventListener("keydown", (e) => { keys.add(e.code); });
    window.addEventListener("keyup", (e) => { keys.delete(e.code); });

    function keyboardAxes() {
      let x = 0, y = 0;
      const left  = keys.has("ArrowLeft") || keys.has("KeyA");
      const right = keys.has("ArrowRight")|| keys.has("KeyD");
      const up    = keys.has("ArrowUp")   || keys.has("KeyW");
      const down  = keys.has("ArrowDown") || keys.has("KeyS");
      if (left) x -= 1;
      if (right) x += 1;
      if (up) y += 1;
      if (down) y -= 1;
      return { x, y };
    }

    // --- Simple driving ---
    const state = {
      speed: 0,
      yaw: 0,
      steer: 0,
      brakeActive: false
    };

    let inputX = 0;
    let inputY = 0;

    const MAX_FWD = 18.0;
    const MAX_REV = 9.0;
    const ACCEL = 26.0;   // units/s^2
    const DRAG = 6.0;     // slows down when no throttle
    const TURN = 2.2;     // radians/sec at full steer (scaled by speed)

    const bounds = 95; // map half-size clamp

    // Camera follow (portrait-friendly)
    const camOffset = new THREE.Vector3(0, 6.0, -12.0);
    const camLookAhead = new THREE.Vector3(0, 1.2, 6.5);

    function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }
    function approach(current, target, maxDelta) {
      const delta = target - current;
      if (Math.abs(delta) <= maxDelta) return target;
      return current + Math.sign(delta) * maxDelta;
    }

    let last = performance.now();
    function tick(now) {
      const dt = Math.min((now - last) / 1000, 0.033);
      last = now;

      if (!car) {
        requestAnimationFrame(tick);
        return;
      }

      // Prefer joystick; if idle, use keyboard.
      let ax = joyX;
      let ay = joyY;
      if ((!joyActive || !isCoarsePointer) && ax === 0 && ay === 0) {
        const k = keyboardAxes();
        ax = k.x;
        ay = k.y;
      }

      // Smooth input so key presses feel gentle on desktop.
      const INPUT_ACCEL = 5.0;
      inputX = approach(inputX, ax, INPUT_ACCEL * dt);
      inputY = approach(inputY, ay, INPUT_ACCEL * dt);
      ax = inputX;
      ay = inputY;

      // Target speed from throttle (ay)
      let targetSpeed = 0;
      if (ay > 0) targetSpeed = ay * MAX_FWD;
      else if (ay < 0) targetSpeed = ay * MAX_REV; // negative

      // Accel towards target, otherwise drag
      if (targetSpeed !== 0) {
        state.speed = approach(state.speed, targetSpeed, ACCEL * dt);
      } else {
        state.speed = approach(state.speed, 0, DRAG * dt);
      }

      // Turning scales with speed (no rotation while stopped)
      const speedFactor = clamp(Math.abs(state.speed) / MAX_FWD, 0, 1);
      const steer = state.speed < -0.05 ? -ax : ax;
      const turnRate = -steer * TURN * speedFactor;
      state.yaw += turnRate * dt;

      const visualSteer = -clamp(ax, -1, 1) * (Math.PI / 7);
      state.steer = visualSteer;

      car.rotation.y = state.yaw;

      // Move forward in car's local +Z
      const forward = new THREE.Vector3(0, 0, 1).applyEuler(car.rotation);
      car.position.addScaledVector(forward, state.speed * dt);

      const rollDelta = (state.speed / (car.userData.wheelRadius || 1)) * dt;
      applyWheelPose(car, visualSteer, rollDelta);

      if (car.userData.rearLights) {
        updateRearLights(car.userData.rearLights, dt, state.speed, targetSpeed, ay, car.userData.lightsOn);
      }

      // Clamp to bounds (soft wall)
      car.position.x = clamp(car.position.x, -bounds, bounds);
      car.position.z = clamp(car.position.z, -bounds, bounds);
      car.position.y = 0;

      // Camera follow
      const offset = camOffset.clone().applyEuler(car.rotation);
      const desiredCam = car.position.clone().add(offset);
      camera.position.lerp(desiredCam, 1 - Math.pow(0.001, dt)); // smooth

      // Reset up before lookAt so roll never leaks into the base orientation.
      camera.up.set(0, 1, 0);
      const look = camLookAhead.clone().applyEuler(car.rotation).add(car.position);
      camera.lookAt(look);

      const braking = state.speed > 0.2 && targetSpeed < state.speed - 0.12;
      const reversing = state.speed < -0.15;
      state.brakeActive = braking || reversing;
      car.userData.brakeActive = state.brakeActive;
      car.userData.applyLights?.(state.brakeActive);

      updateRemotePlayers(dt);

      if (NETWORK.mode === "online") {
        sendStateSnapshot();
      }

      renderer.render(scene, camera);
      requestAnimationFrame(tick);
    }
    async function startGame() {
      await setupPlayerCar();
      initNetwork();
      requestAnimationFrame(tick);
    }
    startGame();

    // Resize
    function onResize() {
      renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
      renderer.setSize(window.innerWidth, window.innerHeight);
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
    }
    window.addEventListener("resize", onResize);
    window.addEventListener("orientationchange", onResize);
    onResize();
  </script>
</body>
</html>
