<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport"
        content="width=device-width, height=device-height, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <title>Mini Car 3D</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #0b0f16;
      touch-action: none;          /* no scroll/zoom */
      overscroll-behavior: none;   /* stop bounce */
      -webkit-user-select: none;
      user-select: none;
    }
    #wrap {
      position: fixed;
      inset: 0;
      width: 100vw;
      height: 100vh;
      overflow: hidden;
      touch-action: none;
    }
    canvas {
      display: block;
      width: 100%;
      height: 100%;
      touch-action: none;
    }

    /* Minimal UI */
    #hud {
      position: fixed;
      inset: 0;
      pointer-events: none;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      color: rgba(255,255,255,0.9);
    }
    #netStatus {
      position: absolute;
      top: calc(env(safe-area-inset-top, 0px) + 12px);
      left: calc(env(safe-area-inset-left, 0px) + 12px);
      padding: 8px 12px;
      border-radius: 12px;
      background: rgba(8, 12, 18, 0.65);
      border: 1px solid rgba(255,255,255,0.08);
      box-shadow: 0 8px 24px rgba(0,0,0,0.35);
      font-size: 12px;
      letter-spacing: 0.02em;
      pointer-events: none;
      backdrop-filter: blur(10px);
    }
    #netStatus.net-online { color: #a5ffb1; }
    #netStatus.net-offline { color: #ff9f9f; }
    /* One joystick = minimum buttons */
    #joy {
      position: absolute;
      bottom: calc(env(safe-area-inset-bottom, 0px) + 22px);
      left: 50%;
      transform: translateX(-50%);
      width: 150px;
      height: 150px;
      pointer-events: auto; /* only this accepts input */
      touch-action: none;
    }
    #joyBase {
      position: absolute;
      inset: 0;
      border-radius: 999px;
      background: rgba(255,255,255,0.06);
      border: 1px solid rgba(255,255,255,0.12);
      backdrop-filter: blur(10px);
    }
    #joyNub {
      position: absolute;
      left: 50%;
      top: 50%;
      width: 62px;
      height: 62px;
      transform: translate(-50%, -50%);
      border-radius: 999px;
      background: rgba(255,255,255,0.14);
      border: 1px solid rgba(255,255,255,0.18);
      box-shadow: 0 10px 22px rgba(0,0,0,0.35);
    }

    @media (orientation: landscape) {
      #joy {
        left: 24%;
      }
    }

  </style>
</head>

<body>
  <div id="wrap"></div>

  <div id="hud">
    <div id="netStatus" class="net-offline">Offline режим</div>
    <div id="joy" aria-label="joystick">
      <div id="joyBase"></div>
      <div id="joyNub"></div>
    </div>
  </div>

  <script type="module">
    import * as THREE from "https://unpkg.com/three@0.160.0/build/three.module.js";
    import { GLTFLoader } from "https://unpkg.com/three@0.160.0/examples/jsm/loaders/GLTFLoader.js";
    import { clone as cloneSkeleton } from "https://unpkg.com/three@0.160.0/examples/jsm/utils/SkeletonUtils.js";

    // --- Hard stop for iOS pinch / double-tap zoom antics ---
    document.addEventListener("gesturestart", (e) => e.preventDefault(), { passive: false });
    document.addEventListener("gesturechange", (e) => e.preventDefault(), { passive: false });
    document.addEventListener("gestureend", (e) => e.preventDefault(), { passive: false });
    ["touchstart","touchmove","touchend"].forEach(evt => {
      document.addEventListener(evt, (e) => e.preventDefault(), { passive: false });
    });

    const wrap = document.getElementById("wrap");
    const hud = document.getElementById("hud");
    const netStatusEl = document.getElementById("netStatus");

    const NETWORK = {
      defaultHost: "irgri.uk",
      localHost: "localhost:3000",
      mode: "offline",
      socket: null,
      id: null,
      reconnectTimer: null,
      lastSend: 0
    };

    function setNetStatus(text, online = false) {
      netStatusEl.textContent = text;
      netStatusEl.classList.toggle("net-online", online);
      netStatusEl.classList.toggle("net-offline", !online);
    }

    // --- Renderer ---
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setClearColor(0x0b0f16, 1);
    renderer.outputEncoding = THREE.sRGBEncoding;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    wrap.appendChild(renderer.domElement);

    // --- Scene / Camera ---
    const scene = new THREE.Scene();
    scene.fog = new THREE.Fog(0x0b0f16, 35, 140);

    const camera = new THREE.PerspectiveCamera(
      60,
      window.innerWidth / window.innerHeight,
      0.1,
      400
    );

    // Lights (simple + cheap)
    const hemi = new THREE.HemisphereLight(0xdfe9ff, 0x1a2433, 0.9);
    scene.add(hemi);

    const sun = new THREE.DirectionalLight(0xffffff, 0.9);
    sun.position.set(12, 18, 10);
    scene.add(sun);

    // --- Ground: empty map ---
    const groundGeo = new THREE.PlaneGeometry(220, 220, 1, 1);
    const groundMat = new THREE.MeshStandardMaterial({
      color: 0x232a35,
      roughness: 1.0,
      metalness: 0.0
    });
    const ground = new THREE.Mesh(groundGeo, groundMat);
    ground.rotation.x = -Math.PI / 2;
    ground.position.y = 0;
    scene.add(ground);

    const grid = new THREE.GridHelper(220, 44, 0x3a4454, 0x2a3342);
    grid.material.transparent = true;
    grid.material.opacity = 0.25;
    grid.position.y = 0.01;
    scene.add(grid);

    function makeNoiseNormalTexture(size = 128, spread = 6) {
      const data = new Uint8Array(size * size * 3);
      for (let i = 0; i < size * size; i++) {
        const base = 128;
        const nx = base + Math.floor((Math.random() * 2 - 1) * spread);
        const ny = base + Math.floor((Math.random() * 2 - 1) * spread);
        const softness = 255 - Math.min(48, Math.abs(nx - base) * 2 + Math.abs(ny - base) * 2);
        data[i * 3 + 0] = THREE.MathUtils.clamp(nx, 0, 255);
        data[i * 3 + 1] = THREE.MathUtils.clamp(ny, 0, 255);
        data[i * 3 + 2] = THREE.MathUtils.clamp(softness, 0, 255);
      }
      const tex = new THREE.DataTexture(data, size, size, THREE.RGBFormat);
      tex.needsUpdate = true;
      tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
      tex.minFilter = THREE.LinearMipMapLinearFilter;
      tex.magFilter = THREE.LinearFilter;
      tex.anisotropy = 4;
      return tex;
    }

    function makeRadialGlowTexture(size = 256, color = "#ff2b3a") {
      const canvas = document.createElement("canvas");
      canvas.width = canvas.height = size;
      const ctx = canvas.getContext("2d");
      const radius = size / 2;
      const grad = ctx.createRadialGradient(radius, radius, radius * 0.1, radius, radius, radius * 0.95);
      const col = new THREE.Color(color);
      const solid = `rgba(${Math.round(col.r * 255)},${Math.round(col.g * 255)},${Math.round(col.b * 255)},`;
      grad.addColorStop(0, `${solid}0.9)`);
      grad.addColorStop(0.35, `${solid}0.65)`);
      grad.addColorStop(0.75, `${solid}0.22)`);
      grad.addColorStop(1, `${solid}0)`);
      ctx.fillStyle = grad;
      ctx.fillRect(0, 0, size, size);

      const tex = new THREE.CanvasTexture(canvas);
      tex.colorSpace = THREE.SRGBColorSpace;
      tex.minFilter = THREE.LinearMipMapLinearFilter;
      tex.magFilter = THREE.LinearFilter;
      tex.anisotropy = 4;
      return tex;
    }

    // --- Car (GLB model) ---
    const gltfLoader = new GLTFLoader();
    const carModelPromise = loadCarModel();

    let car = null;

    function loadCarModel() {
      return gltfLoader.loadAsync("models/normalcar1.glb").then((gltf) => gltf.scene);
    }

    let loggedCarStructure = false;
    function logCarStructure(root) {
      if (loggedCarStructure) return;
      loggedCarStructure = true;
      const lines = [];
      root.traverse((child) => {
        const mats = [];
        const material = child.material;
        if (Array.isArray(material)) {
          material.forEach((m) => m && mats.push(m.name || "(mat)"));
        } else if (material) {
          mats.push(material.name || "(mat)");
        }
        lines.push(`${child.name || child.type}${mats.length ? ` [${mats.join(", ")}]` : ""}`);
      });
      console.groupCollapsed("[CarModel] Scene graph");
      lines.forEach((l) => console.log(l));
      console.groupEnd();
    }

    function cloneMaterials(obj) {
      obj.traverse((child) => {
        if (!child.isMesh || !child.material) return;
        if (Array.isArray(child.material)) {
          child.material = child.material.map((mat) => mat?.clone?.() || mat);
        } else {
          child.material = child.material.clone();
        }
      });
    }

    function findMaterials(root, match) {
      const result = new Set();
      root.traverse((child) => {
        if (!child.isMesh || !child.material) return;
        const mats = Array.isArray(child.material) ? child.material : [child.material];
        mats.forEach((mat) => {
          const name = (mat?.name || child.name || "").toLowerCase();
          if (match(name)) result.add(mat);
        });
      });
      return Array.from(result);
    }

    function findWheelCandidates(root) {
      const wheels = [];
      root.traverse((child) => {
        const name = (child.name || "").toLowerCase();
        if (name.includes("wheel") || name.includes("tyre") || name.includes("tire")) {
          wheels.push(child);
        }
      });
      return wheels;
    }

    function categorizeWheels(root) {
      const wheelNodes = findWheelCandidates(root);
      if (wheelNodes.length === 0) {
        logCarStructure(root);
        return { wheels: [], steeringPivots: [], radius: 0.3 };
      }

      root.updateMatrixWorld(true);
      const temp = new THREE.Vector3();
      const wheels = wheelNodes.map((mesh) => ({
        mesh,
        position: mesh.getWorldPosition(temp.clone()),
      }));

      const sorted = wheels.sort((a, b) => b.position.z - a.position.z);
      const front = sorted.slice(0, 2);

      const steeringPivots = front.map(({ mesh }) => {
        const parent = mesh.parent || mesh;
        const parentName = (parent.name || "").toLowerCase();
        if (parent !== root && (parentName.includes("pivot") || parentName.includes("steer"))) {
          return parent;
        }
        return mesh;
      });

      const wheelGroups = wheels.map(({ mesh }) => mesh);

      const radius = (() => {
        const box = new THREE.Box3().setFromObject(wheels[0].mesh);
        return Math.max(0.15, (box.max.y - box.min.y) / 2);
      })();

      return { wheels: wheelGroups, steeringPivots, radius };
    }

    function collectBodyMaterials(root) {
      const candidates = findMaterials(root, (name) =>
        name.includes("body") || name.includes("paint") || name.includes("car")
      );
      if (candidates.length === 0) {
        root.traverse((child) => {
          if (child.isMesh && child.material && !Array.isArray(child.material) && child.material.color) {
            candidates.push(child.material);
          }
        });
        logCarStructure(root);
      }
      return candidates;
    }

    function collectLightMaterials(root) {
      const headlights = findMaterials(root, (name) =>
        name.includes("head") || name.includes("front") || name.includes("lamp")
      );
      const tailLights = findMaterials(root, (name) =>
        name.includes("tail") || name.includes("rear") || name.includes("back") || name.includes("brake")
      );
      if (headlights.length === 0 || tailLights.length === 0) {
        logCarStructure(root);
      }
      return { headlights, tailLights };
    }

    async function makeCar() {
      const baseScene = await carModelPromise;
      const car = cloneSkeleton(baseScene);
      cloneMaterials(car);

      const { wheels, steeringPivots, radius } = categorizeWheels(car);
      const { headlights, tailLights } = collectLightMaterials(car);
      const bodyMaterials = collectBodyMaterials(car);

      const headlightIntensities = headlights.map((m) => m.emissiveIntensity ?? 1);
      const tailLightIntensities = tailLights.map((m) => m.emissiveIntensity ?? 1);

      car.userData.wheelGroups = wheels;
      car.userData.steeringPivots = steeringPivots;
      car.userData.wheelRadius = radius;
      car.userData.lightsOn = true;
      car.userData.brakeActive = false;

      car.userData.setPlayerColor = (color) => {
        bodyMaterials.forEach((mat) => {
          if (mat?.color) mat.color.set(color);
        });
      };

      car.userData.setLights = (on) => {
        car.userData.lightsOn = Boolean(on);
        car.userData.applyLights?.(car.userData.brakeActive);
      };

      car.userData.applyLights = (brake = false) => {
        headlights.forEach((mat, i) => {
          if (typeof mat.emissiveIntensity === "number") {
            mat.emissiveIntensity = car.userData.lightsOn ? headlightIntensities[i] : 0.0;
          }
          mat.visible = car.userData.lightsOn;
        });
        tailLights.forEach((mat, i) => {
          const base = tailLightIntensities[i];
          if (typeof mat.emissiveIntensity === "number") {
            mat.emissiveIntensity = car.userData.lightsOn || brake ? (brake ? base * 2.4 : base) : 0.02;
          }
          mat.visible = car.userData.lightsOn || brake;
        });
      };

      car.userData.applyLights(false);

      return car;
    }

    async function setupPlayerCar() {
      car = await makeCar();
      scene.add(car);
    }


    // --- Multiplayer (online/offline aware) ---
    const remotePlayers = new Map();

    function hashHue(id) {
      let hash = 0;
      for (let i = 0; i < id.length; i++) {
        hash = (hash * 31 + id.charCodeAt(i)) >>> 0;
      }
      return (hash % 360) / 360;
    }

    function colorizeCar(mesh, hue) {
      const color = new THREE.Color();
      color.setHSL(hue, 0.72, 0.52);
      mesh.userData.setPlayerColor?.(color);
    }

    async function spawnRemotePlayer(id, snapshot) {
      if (remotePlayers.has(id)) return;
      const placeholder = { mesh: null, target: null, loading: true };
      remotePlayers.set(id, placeholder);
      const ghost = await makeCar();
      colorizeCar(ghost, hashHue(id));
      ghost.userData.isRemote = true;
      ghost.userData.applyLights?.(false);
      scene.add(ghost);
      placeholder.mesh = ghost;
      placeholder.loading = false;
      applyRemoteState(id, snapshot || { p: [0, 0, 0], y: 0, s: 0 });
    }

    function removeRemotePlayer(id) {
      const player = remotePlayers.get(id);
      if (!player) return;
      if (player.mesh) {
        scene.remove(player.mesh);
        player.mesh.traverse((child) => {
          if (child.geometry) child.geometry.dispose?.();
          if (child.material) child.material.dispose?.();
        });
      }
      remotePlayers.delete(id);
    }

    function applyRemoteState(id, state) {
      const player = remotePlayers.get(id);
      if (!player) return;
      const target = {
        position: new THREE.Vector3(state.p?.[0] || 0, state.p?.[1] || 0, state.p?.[2] || 0),
        yaw: state.y || 0,
        speed: state.s || 0,
        steer: state.st || 0,
        brake: Boolean(state.b),
        received: performance.now()
      };
      player.target = target;
    }

    function updateRemotePlayers(dt) {
      const follow = 1 - Math.pow(0.0015, dt);
      for (const player of remotePlayers.values()) {
        if (!player.mesh || !player.target) continue;
        player.mesh.position.lerp(player.target.position, follow);
        const currentYaw = player.mesh.rotation.y;
        const deltaYaw = ((player.target.yaw - currentYaw + Math.PI * 3) % (Math.PI * 2)) - Math.PI;
        player.mesh.rotation.y = currentYaw + deltaYaw * follow;
        const rollDelta = (player.target.speed / (player.mesh.userData.wheelRadius || 1)) * dt;
        player.mesh.userData.wheelGroups?.forEach((group) => {
          group.rotation.x -= rollDelta;
        });
        player.mesh.userData.steeringPivots?.forEach((pivot) => {
          pivot.rotation.y = player.target.steer || 0;
        });
        player.mesh.userData.brakeActive = Boolean(player.target.brake);
        player.mesh.userData.applyLights?.(player.mesh.userData.brakeActive);
      }
    }

    function resolveServerHost() {
      const host = location.hostname;
      if (host === "localhost" || host === "127.0.0.1") return NETWORK.localHost;
      if (!host || host === "") return NETWORK.defaultHost;
      return NETWORK.defaultHost;
    }

    async function checkServerAvailability(host, timeoutMs = 1800) {
      const controller = new AbortController();
      const timer = setTimeout(() => controller.abort(), timeoutMs);
      const protocol = host.includes("localhost") || host.includes("127.0.0.1") ? "http" : "https";
      try {
        const res = await fetch(`${protocol}://${host}/health`, {
          signal: controller.signal,
          cache: "no-store"
        });
        return res.ok;
      } catch (err) {
        return false;
      } finally {
        clearTimeout(timer);
      }
    }

    function cleanSocket() {
      if (NETWORK.socket) {
        NETWORK.socket.close();
        NETWORK.socket = null;
      }
    }

    function scheduleReconnect() {
      if (NETWORK.reconnectTimer) return;
      NETWORK.reconnectTimer = setTimeout(() => {
        NETWORK.reconnectTimer = null;
        initNetwork();
      }, 2500);
    }

    function sendStateSnapshot() {
      if (!NETWORK.socket || NETWORK.socket.readyState !== WebSocket.OPEN) return;
      if (!car) return;
      const now = performance.now();
      if (now - NETWORK.lastSend < 50) return; // ~20 Hz
      NETWORK.lastSend = now;
      const payload = {
        type: "state",
        state: {
          p: [Number(car.position.x.toFixed(3)), Number(car.position.y.toFixed(3)), Number(car.position.z.toFixed(3))],
          y: Number(state.yaw.toFixed(4)),
          s: Number(state.speed.toFixed(3)),
          st: Number(state.steer.toFixed(4)),
          b: Boolean(state.brakeActive)
        }
      };
      NETWORK.socket.send(JSON.stringify(payload));
    }

    function handleMessage(evt) {
      let data;
      try {
        data = JSON.parse(evt.data);
      } catch (err) {
        return;
      }

      if (data.type === "hello") {
        NETWORK.id = data.id;
        setNetStatus(`Online: ${resolveServerHost()}`, true);
        if (Array.isArray(data.players)) {
          data.players.forEach((p) => {
            if (!remotePlayers.has(p.id)) spawnRemotePlayer(p.id, p.state).catch((err) => console.warn("Remote spawn failed", err));
            else applyRemoteState(p.id, p.state);
          });
        }
        sendStateSnapshot();
      } else if (data.type === "state" && data.id && data.id !== NETWORK.id) {
        if (!remotePlayers.has(data.id)) spawnRemotePlayer(data.id, data.state).catch((err) => console.warn("Remote spawn failed", err));
        else applyRemoteState(data.id, data.state);
      } else if (data.type === "player-left" && data.id) {
        removeRemotePlayer(data.id);
      } else if (data.type === "player-joined" && data.id && data.id !== NETWORK.id) {
        if (!remotePlayers.has(data.id)) spawnRemotePlayer(data.id, { p: [0, 0, 0], y: 0, s: 0 }).catch((err) => console.warn("Remote spawn failed", err));
      }
    }

    async function initNetwork() {
      cleanSocket();
      const host = resolveServerHost();
      const available = await checkServerAvailability(host);
      if (!available) {
        NETWORK.mode = "offline";
        setNetStatus("Offline режим (сервер недоступен)", false);
        scheduleReconnect();
        return;
      }

      const protocol = host.includes("localhost") || host.includes("127.0.0.1") ? "ws" : "wss";
      const ws = new WebSocket(`${protocol}://${host}/ws`);
      ws.addEventListener("open", () => {
        NETWORK.socket = ws;
        NETWORK.mode = "online";
        NETWORK.lastSend = 0;
        setNetStatus(`Online: ${host}`, true);
        sendStateSnapshot();
      });
      ws.addEventListener("message", handleMessage);
      ws.addEventListener("close", () => {
        NETWORK.mode = "offline";
        setNetStatus("Offline режим (нет соединения)", false);
        NETWORK.socket = null;
        scheduleReconnect();
      });
      ws.addEventListener("error", () => {
        setNetStatus("Offline режим (ошибка связи)", false);
      });
    }

    // --- Input: single joystick + keyboard fallback ---
    const joy = document.getElementById("joy");
    const nub = document.getElementById("joyNub");
    const isCoarsePointer = window.matchMedia("(pointer: coarse)").matches;
    if (!isCoarsePointer) {
      joy.style.display = "none";
    }

    let joyActive = false;
    let joyPointerId = null;
    let joyX = 0;  // -1..1
    let joyY = 0;  // -1..1

    function setNub(dx, dy) {
      nub.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
    }

    function handleJoyEvent(e) {
      e.preventDefault();
      const rect = joy.getBoundingClientRect();
      const cx = rect.left + rect.width / 2;
      const cy = rect.top + rect.height / 2;
      const radius = rect.width * 0.36; // nub travel

      const px = e.clientX;
      const py = e.clientY;

      let dx = px - cx;
      let dy = py - cy;

      const len = Math.hypot(dx, dy);
      if (len > radius) {
        dx = (dx / len) * radius;
        dy = (dy / len) * radius;
      }

      setNub(dx, dy);

      // Normalize to -1..1. Up on screen = forward throttle.
      joyX = dx / radius;
      joyY = -dy / radius;

      // Deadzone (so it doesn't drift)
      const dz = 0.08;
      if (Math.abs(joyX) < dz) joyX = 0;
      if (Math.abs(joyY) < dz) joyY = 0;
    }

    joy.addEventListener("pointerdown", (e) => {
      joyActive = true;
      joyPointerId = e.pointerId;
      joy.setPointerCapture(joyPointerId);
      handleJoyEvent(e);
    }, { passive: false });

    joy.addEventListener("pointermove", (e) => {
      if (!joyActive || e.pointerId !== joyPointerId) return;
      handleJoyEvent(e);
    }, { passive: false });

    function releaseJoy() {
      joyActive = false;
      joyPointerId = null;
      joyX = 0;
      joyY = 0;
      setNub(0, 0);
    }

    joy.addEventListener("pointerup", (e) => {
      if (e.pointerId !== joyPointerId) return;
      releaseJoy();
    }, { passive: false });

    joy.addEventListener("pointercancel", releaseJoy, { passive: false });

    // Keyboard fallback (PC)
    const keys = new Set();
    window.addEventListener("keydown", (e) => { keys.add(e.code); });
    window.addEventListener("keyup", (e) => { keys.delete(e.code); });

    function keyboardAxes() {
      let x = 0, y = 0;
      const left  = keys.has("ArrowLeft") || keys.has("KeyA");
      const right = keys.has("ArrowRight")|| keys.has("KeyD");
      const up    = keys.has("ArrowUp")   || keys.has("KeyW");
      const down  = keys.has("ArrowDown") || keys.has("KeyS");
      if (left) x -= 1;
      if (right) x += 1;
      if (up) y += 1;
      if (down) y -= 1;
      return { x, y };
    }

    // --- Simple driving ---
    const state = {
      speed: 0,
      yaw: 0,
      steer: 0,
      brakeActive: false
    };

    let inputX = 0;
    let inputY = 0;

    const MAX_FWD = 18.0;
    const MAX_REV = 9.0;
    const ACCEL = 26.0;   // units/s^2
    const DRAG = 6.0;     // slows down when no throttle
    const TURN = 2.2;     // radians/sec at full steer (scaled by speed)

    const bounds = 95; // map half-size clamp

    // Camera follow (portrait-friendly)
    const camOffset = new THREE.Vector3(0, 6.0, -12.0);
    const camLookAhead = new THREE.Vector3(0, 1.2, 6.5);

    function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }
    function approach(current, target, maxDelta) {
      const delta = target - current;
      if (Math.abs(delta) <= maxDelta) return target;
      return current + Math.sign(delta) * maxDelta;
    }

    let last = performance.now();
    function tick(now) {
      const dt = Math.min((now - last) / 1000, 0.033);
      last = now;

      if (!car) {
        requestAnimationFrame(tick);
        return;
      }

      // Prefer joystick; if idle, use keyboard.
      let ax = joyX;
      let ay = joyY;
      if ((!joyActive || !isCoarsePointer) && ax === 0 && ay === 0) {
        const k = keyboardAxes();
        ax = k.x;
        ay = k.y;
      }

      // Smooth input so key presses feel gentle on desktop.
      const INPUT_ACCEL = 5.0;
      inputX = approach(inputX, ax, INPUT_ACCEL * dt);
      inputY = approach(inputY, ay, INPUT_ACCEL * dt);
      ax = inputX;
      ay = inputY;

      // Target speed from throttle (ay)
      let targetSpeed = 0;
      if (ay > 0) targetSpeed = ay * MAX_FWD;
      else if (ay < 0) targetSpeed = ay * MAX_REV; // negative

      // Accel towards target, otherwise drag
      if (targetSpeed !== 0) {
        state.speed = approach(state.speed, targetSpeed, ACCEL * dt);
      } else {
        state.speed = approach(state.speed, 0, DRAG * dt);
      }

      // Turning scales with speed (no rotation while stopped)
      const speedFactor = clamp(Math.abs(state.speed) / MAX_FWD, 0, 1);
      const steer = state.speed < -0.05 ? -ax : ax;
      const turnRate = -steer * TURN * speedFactor;
      state.yaw += turnRate * dt;

      const visualSteer = -clamp(ax, -1, 1) * (Math.PI / 7);
      state.steer = visualSteer;
      car.userData.steeringPivots?.forEach((pivot) => {
        pivot.rotation.y = visualSteer;
      });

      car.rotation.y = state.yaw;

      // Move forward in car's local +Z
      const forward = new THREE.Vector3(0, 0, 1).applyEuler(car.rotation);
      car.position.addScaledVector(forward, state.speed * dt);

      const rollDelta = (state.speed / (car.userData.wheelRadius || 1)) * dt;
      car.userData.wheelGroups?.forEach((group) => {
        group.rotation.x -= rollDelta;
      });

      // Clamp to bounds (soft wall)
      car.position.x = clamp(car.position.x, -bounds, bounds);
      car.position.z = clamp(car.position.z, -bounds, bounds);
      car.position.y = 0;

      // Camera follow
      const offset = camOffset.clone().applyEuler(car.rotation);
      const desiredCam = car.position.clone().add(offset);
      camera.position.lerp(desiredCam, 1 - Math.pow(0.001, dt)); // smooth

      // Reset up before lookAt so roll never leaks into the base orientation.
      camera.up.set(0, 1, 0);
      const look = camLookAhead.clone().applyEuler(car.rotation).add(car.position);
      camera.lookAt(look);

      const braking = state.speed > 0.2 && targetSpeed < state.speed - 0.12;
      const reversing = state.speed < -0.15;
      state.brakeActive = braking || reversing;
      car.userData.brakeActive = state.brakeActive;
      car.userData.applyLights?.(state.brakeActive);

      updateRemotePlayers(dt);

      if (NETWORK.mode === "online") {
        sendStateSnapshot();
      }

      renderer.render(scene, camera);
      requestAnimationFrame(tick);
    }
    async function startGame() {
      await setupPlayerCar();
      initNetwork();
      requestAnimationFrame(tick);
    }
    startGame();

    // Resize
    function onResize() {
      renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
      renderer.setSize(window.innerWidth, window.innerHeight);
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
    }
    window.addEventListener("resize", onResize);
    window.addEventListener("orientationchange", onResize);
    onResize();
  </script>
</body>
</html>
