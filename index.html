<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport"
        content="width=device-width, height=device-height, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <title>Mini Car 3D</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #0b0f16;
      touch-action: none;          /* no scroll/zoom */
      overscroll-behavior: none;   /* stop bounce */
      -webkit-user-select: none;
      user-select: none;
    }
    #wrap {
      position: fixed;
      inset: 0;
      width: 100vw;
      height: 100vh;
      overflow: hidden;
      touch-action: none;
    }
    canvas {
      display: block;
      width: 100%;
      height: 100%;
      touch-action: none;
    }

    /* Minimal UI */
    #hud {
      position: fixed;
      inset: 0;
      pointer-events: none;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      color: rgba(255,255,255,0.9);
    }
    #netStatus {
      position: absolute;
      top: calc(env(safe-area-inset-top, 0px) + 12px);
      left: calc(env(safe-area-inset-left, 0px) + 12px);
      padding: 8px 12px;
      border-radius: 12px;
      background: rgba(8, 12, 18, 0.65);
      border: 1px solid rgba(255,255,255,0.08);
      box-shadow: 0 8px 24px rgba(0,0,0,0.35);
      font-size: 12px;
      letter-spacing: 0.02em;
      pointer-events: none;
      backdrop-filter: blur(10px);
    }
    #netStatus.net-online { color: #a5ffb1; }
    #netStatus.net-offline { color: #ff9f9f; }
    /* One joystick = minimum buttons */
    #joy {
      position: absolute;
      bottom: calc(env(safe-area-inset-bottom, 0px) + 22px);
      left: 50%;
      transform: translateX(-50%);
      width: 150px;
      height: 150px;
      pointer-events: auto; /* only this accepts input */
      touch-action: none;
    }
    #joyBase {
      position: absolute;
      inset: 0;
      border-radius: 999px;
      background: rgba(255,255,255,0.06);
      border: 1px solid rgba(255,255,255,0.12);
      backdrop-filter: blur(10px);
    }
    #joyNub {
      position: absolute;
      left: 50%;
      top: 50%;
      width: 62px;
      height: 62px;
      transform: translate(-50%, -50%);
      border-radius: 999px;
      background: rgba(255,255,255,0.14);
      border: 1px solid rgba(255,255,255,0.18);
      box-shadow: 0 10px 22px rgba(0,0,0,0.35);
    }

    @media (orientation: landscape) {
      #joy {
        left: 24%;
      }
    }

  </style>
</head>

<body>
  <div id="wrap"></div>

  <div id="hud">
    <div id="netStatus" class="net-offline">Offline режим</div>
    <div id="joy" aria-label="joystick">
      <div id="joyBase"></div>
      <div id="joyNub"></div>
    </div>
  </div>

  <script type="module">
    import * as THREE from "https://unpkg.com/three@0.160.0/build/three.module.js";

    // --- Hard stop for iOS pinch / double-tap zoom antics ---
    document.addEventListener("gesturestart", (e) => e.preventDefault(), { passive: false });
    document.addEventListener("gesturechange", (e) => e.preventDefault(), { passive: false });
    document.addEventListener("gestureend", (e) => e.preventDefault(), { passive: false });
    ["touchstart","touchmove","touchend"].forEach(evt => {
      document.addEventListener(evt, (e) => e.preventDefault(), { passive: false });
    });

    const wrap = document.getElementById("wrap");
    const hud = document.getElementById("hud");
    const netStatusEl = document.getElementById("netStatus");

    const NETWORK = {
      defaultHost: "irgri.uk",
      localHost: "localhost:3000",
      mode: "offline",
      socket: null,
      id: null,
      reconnectTimer: null,
      lastSend: 0
    };

    function setNetStatus(text, online = false) {
      netStatusEl.textContent = text;
      netStatusEl.classList.toggle("net-online", online);
      netStatusEl.classList.toggle("net-offline", !online);
    }

    // --- Renderer ---
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setClearColor(0x0b0f16, 1);
    renderer.outputEncoding = THREE.sRGBEncoding;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    wrap.appendChild(renderer.domElement);

    // --- Scene / Camera ---
    const scene = new THREE.Scene();
    scene.fog = new THREE.Fog(0x0b0f16, 35, 140);

    const camera = new THREE.PerspectiveCamera(
      60,
      window.innerWidth / window.innerHeight,
      0.1,
      400
    );

    // Lights (simple + cheap)
    const hemi = new THREE.HemisphereLight(0xdfe9ff, 0x1a2433, 0.9);
    scene.add(hemi);

    const sun = new THREE.DirectionalLight(0xffffff, 0.9);
    sun.position.set(12, 18, 10);
    scene.add(sun);

    // --- Ground: empty map ---
    const groundGeo = new THREE.PlaneGeometry(220, 220, 1, 1);
    const groundMat = new THREE.MeshStandardMaterial({
      color: 0x232a35,
      roughness: 1.0,
      metalness: 0.0
    });
    const ground = new THREE.Mesh(groundGeo, groundMat);
    ground.rotation.x = -Math.PI / 2;
    ground.position.y = 0;
    scene.add(ground);

    const grid = new THREE.GridHelper(220, 44, 0x3a4454, 0x2a3342);
    grid.material.transparent = true;
    grid.material.opacity = 0.25;
    grid.position.y = 0.01;
    scene.add(grid);

    function makeNoiseNormalTexture(size = 128, spread = 6) {
      const data = new Uint8Array(size * size * 3);
      for (let i = 0; i < size * size; i++) {
        const base = 128;
        const nx = base + Math.floor((Math.random() * 2 - 1) * spread);
        const ny = base + Math.floor((Math.random() * 2 - 1) * spread);
        const softness = 255 - Math.min(48, Math.abs(nx - base) * 2 + Math.abs(ny - base) * 2);
        data[i * 3 + 0] = THREE.MathUtils.clamp(nx, 0, 255);
        data[i * 3 + 1] = THREE.MathUtils.clamp(ny, 0, 255);
        data[i * 3 + 2] = THREE.MathUtils.clamp(softness, 0, 255);
      }
      const tex = new THREE.DataTexture(data, size, size, THREE.RGBFormat);
      tex.needsUpdate = true;
      tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
      tex.minFilter = THREE.LinearMipMapLinearFilter;
      tex.magFilter = THREE.LinearFilter;
      tex.anisotropy = 4;
      return tex;
    }

    function makeRadialGlowTexture(size = 256, color = "#ff2b3a") {
      const canvas = document.createElement("canvas");
      canvas.width = canvas.height = size;
      const ctx = canvas.getContext("2d");
      const radius = size / 2;
      const grad = ctx.createRadialGradient(radius, radius, radius * 0.1, radius, radius, radius * 0.95);
      const col = new THREE.Color(color);
      const solid = `rgba(${Math.round(col.r * 255)},${Math.round(col.g * 255)},${Math.round(col.b * 255)},`;
      grad.addColorStop(0, `${solid}0.9)`);
      grad.addColorStop(0.35, `${solid}0.65)`);
      grad.addColorStop(0.75, `${solid}0.22)`);
      grad.addColorStop(1, `${solid}0)`);
      ctx.fillStyle = grad;
      ctx.fillRect(0, 0, size, size);

      const tex = new THREE.CanvasTexture(canvas);
      tex.colorSpace = THREE.SRGBColorSpace;
      tex.minFilter = THREE.LinearMipMapLinearFilter;
      tex.magFilter = THREE.LinearFilter;
      tex.anisotropy = 4;
      return tex;
    }

    // --- Car (simple geometry, no drama) ---
    function makeCar() {
      const car = new THREE.Group();

      const microNormal = makeNoiseNormalTexture();

      function makeNumberTexture(num = 7) {
        const canvas = document.createElement('canvas');
        canvas.width = canvas.height = 128;
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = 'rgba(255,255,255,0)';
        ctx.fillRect(0, 0, 128, 128);
        ctx.fillStyle = '#f12c4b';
        ctx.strokeStyle = '#0f1624';
        ctx.lineWidth = 6;
        ctx.font = 'bold 92px Inter, system-ui';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(String(num), 64, 72);
        ctx.strokeText(String(num), 64, 72);
        const tex = new THREE.CanvasTexture(canvas);
        tex.colorSpace = THREE.SRGBColorSpace;
        tex.anisotropy = 4;
        return tex;
      }

      const bodyMat = new THREE.MeshStandardMaterial({
        color: 0xff5e6d,
        roughness: 0.45,
        metalness: 0.08,
        normalMap: microNormal,
        normalScale: new THREE.Vector2(0.35, 0.35)
      });
      const cabinMat = new THREE.MeshStandardMaterial({
        color: 0x0f1624,
        roughness: 0.38,
        metalness: 0.03,
        normalMap: microNormal,
        normalScale: new THREE.Vector2(0.25, 0.25)
      });
      const wheelMat = new THREE.MeshStandardMaterial({
        color: 0x1b1b1b,
        roughness: 0.94,
        metalness: 0.02
      });
      const hubMat = new THREE.MeshStandardMaterial({
        color: 0xced3de,
        roughness: 0.32,
        metalness: 0.55
      });
      const headlightMat = new THREE.MeshStandardMaterial({
        color: 0xd9e2ff,
        emissive: 0xf4f7ff,
        emissiveIntensity: 0.8,
        roughness: 0.24,
        metalness: 0.12,
        normalMap: microNormal,
        normalScale: new THREE.Vector2(0.16, 0.16),
        transparent: true,
        opacity: 0.95
      });
      const tailLightMat = new THREE.MeshStandardMaterial({
        color: 0x9f0012,
        emissive: 0xff2b3a,
        emissiveIntensity: 0.38,
        roughness: 0.42,
        metalness: 0.04,
        normalMap: microNormal,
        normalScale: new THREE.Vector2(0.18, 0.18),
        transparent: true,
        opacity: 0.95
      });

      const body = new THREE.Mesh(new THREE.BoxGeometry(1.35, 0.45, 2.4), bodyMat);
      body.position.y = 0.42;
      car.add(body);

      const cabin = new THREE.Mesh(new THREE.BoxGeometry(1.05, 0.42, 1.2), cabinMat);
      cabin.position.set(0, 0.78, -0.1);
      car.add(cabin);

      const bumperMat = new THREE.MeshStandardMaterial({
        color: 0xe0e6f0,
        roughness: 0.82,
        metalness: 0.24,
        normalMap: microNormal,
        normalScale: new THREE.Vector2(0.18, 0.18)
      });
      const bumperF = new THREE.Mesh(new THREE.BoxGeometry(1.25, 0.18, 0.22), bumperMat);
      bumperF.position.set(0, 0.26, 1.18);
      car.add(bumperF);

      const bumperB = new THREE.Mesh(new THREE.BoxGeometry(1.25, 0.18, 0.22), bumperMat);
      bumperB.position.set(0, 0.26, -1.18);
      car.add(bumperB);

      function makeHeadlight(x) {
        const lens = new THREE.Mesh(new THREE.BoxGeometry(0.16, 0.12, 0.06), headlightMat.clone());
        lens.position.set(x, 0.48, 1.22);
        const light = new THREE.SpotLight(0xffffff, 2.65, 30, Math.PI / 6.5, 0.36, 1.05);
        light.position.set(x * 0.92, 0.54, 1.08);
        light.target.position.set(x * 0.6, 0.28, 6.2);
        car.add(light.target);
        car.add(light);
        car.add(lens);
      }

      makeHeadlight(-0.35);
      makeHeadlight(0.35);

      const wheelRadius = 0.22;
      const wheelGeo = new THREE.CylinderGeometry(wheelRadius, wheelRadius, 0.18, 18);
      const hubGeo = new THREE.CylinderGeometry(0.08, 0.08, 0.2, 14);
      const axleGeo = new THREE.CylinderGeometry(0.035, 0.035, 1.35, 10);
      const wheelGroups = [];
      const steeringPivots = [];
      function axleAt(z) {
        const axle = new THREE.Mesh(axleGeo, hubMat);
        axle.rotation.z = Math.PI / 2;
        axle.position.set(0, 0.22, z);
        return axle;
      }
      car.add(axleAt(0.82));
      car.add(axleAt(-0.82));
      function wheelWithHub(x, z, steerable = false) {
        const pivot = new THREE.Group();
        pivot.position.set(x, 0.22, z);

        const group = new THREE.Group();
        group.position.y = 0;

        const w = new THREE.Mesh(wheelGeo, wheelMat);
        w.rotation.z = Math.PI / 2;
        const hub = new THREE.Mesh(hubGeo, hubMat);
        hub.rotation.z = Math.PI / 2;
        group.add(w);
        group.add(hub);

        pivot.add(group);
        wheelGroups.push(group);
        if (steerable) steeringPivots.push(pivot);
        return pivot;
      }
      car.add(wheelWithHub(-0.62, 0.82, true));
      car.add(wheelWithHub( 0.62, 0.82, true));
      car.add(wheelWithHub(-0.62,-0.82));
      car.add(wheelWithHub( 0.62,-0.82));

      const stickerMat = new THREE.MeshStandardMaterial({
        color: 0xffffff,
        roughness: 0.5,
        metalness: 0.0,
        transparent: true,
        opacity: 0.96,
        side: THREE.DoubleSide,
        normalMap: microNormal,
        normalScale: new THREE.Vector2(0.2, 0.2)
      });

      const stripe = new THREE.Mesh(new THREE.PlaneGeometry(0.34, 1.6), stickerMat.clone());
      stripe.material.color.set(0xffd36b);
      stripe.rotation.x = -Math.PI / 2;
      stripe.position.set(-0.35, 0.66, 0.2);
      car.add(stripe);

      const stripe2 = stripe.clone();
      stripe2.position.x = 0.35;
      stripe2.material = stripe.material.clone();
      stripe2.material.color = new THREE.Color(0xffffff);
      car.add(stripe2);

      const doorNumGeo = new THREE.PlaneGeometry(0.64, 0.46);
      const doorNumMat = stickerMat.clone();
      doorNumMat.color.set(0xffffff);
      doorNumMat.map = makeNumberTexture(7);
      doorNumMat.transparent = true;
      const doorNumL = new THREE.Mesh(doorNumGeo, doorNumMat);
      doorNumL.position.set(-0.68, 0.58, 0.2);
      doorNumL.rotation.y = Math.PI / 2;
      car.add(doorNumL);

      const doorNumR = doorNumL.clone();
      doorNumR.position.x = 0.68;
      doorNumR.rotation.y = -Math.PI / 2;
      car.add(doorNumR);

      const badgeMat = stickerMat.clone();
      badgeMat.color.set(0x4fb7ff);
      const badge = new THREE.Mesh(new THREE.PlaneGeometry(0.28, 0.18), badgeMat);
      badge.position.set(0, 0.62, 1.22);
      car.add(badge);

      const brakeLights = [];
      function makeTailLight(x) {
        const lens = new THREE.Mesh(new THREE.CircleGeometry(0.095, 22), tailLightMat.clone());
        lens.position.set(x, 0.44, -1.215);
        lens.rotation.y = Math.PI;

        const halo = new THREE.Mesh(
          new THREE.PlaneGeometry(0.42, 0.42),
          new THREE.MeshBasicMaterial({
            map: makeRadialGlowTexture(256, "#ff2738"),
            transparent: true,
            blending: THREE.AdditiveBlending,
            depthWrite: false,
            opacity: 0.8,
            side: THREE.DoubleSide,
          })
        );
        halo.position.copy(lens.position).add(new THREE.Vector3(0, 0, -0.02));
        halo.rotation.y = Math.PI;

        const aura = new THREE.Mesh(
          new THREE.PlaneGeometry(0.68, 0.68),
          new THREE.MeshBasicMaterial({
            map: makeRadialGlowTexture(256, "#ff5a6b"),
            transparent: true,
            blending: THREE.AdditiveBlending,
            depthWrite: false,
            opacity: 0.0,
            side: THREE.DoubleSide,
          })
        );
        aura.position.copy(lens.position).add(new THREE.Vector3(0, 0, -0.03));
        aura.rotation.y = Math.PI;

        const light = new THREE.SpotLight(0xff2738, 0.32, 8.5, Math.PI / 7.2, 0.52, 1.65);
        light.position.set(x, 0.46, -1.06);
        light.target.position.set(x * 0.85, 0.44, -6.4);
        car.add(light.target);
        car.add(light);
        car.add(lens);
        car.add(halo);
        car.add(aura);
        brakeLights.push({ light, lens, halo, aura });
      }

      makeTailLight(-0.36);
      makeTailLight(0.36);

      // A tiny "arrow" so you always know forward direction
      const nose = new THREE.Mesh(
        new THREE.ConeGeometry(0.18, 0.45, 18),
        new THREE.MeshStandardMaterial({
          color: 0xffd36b,
          roughness: 0.48,
          metalness: 0.05,
          normalMap: microNormal,
          normalScale: new THREE.Vector2(0.22, 0.22)
        })
      );
      nose.rotation.x = Math.PI / 2;
      nose.position.set(0, 0.7, 1.05);
      car.add(nose);

      car.userData.tailLights = brakeLights;
      car.userData.wheelGroups = wheelGroups;
      car.userData.steeringPivots = steeringPivots;
      car.userData.wheelRadius = wheelRadius;

      car.position.set(0, 0, 0);
      return car;
    }

    const car = makeCar();
    scene.add(car);

    // --- Multiplayer (online/offline aware) ---
    const remotePlayers = new Map();

    function hashHue(id) {
      let hash = 0;
      for (let i = 0; i < id.length; i++) {
        hash = (hash * 31 + id.charCodeAt(i)) >>> 0;
      }
      return (hash % 360) / 360;
    }

    function colorizeCar(mesh, hue) {
      mesh.traverse((child) => {
        if (!child.isMesh || !child.material) return;
        const mat = child.material.clone();
        if (mat.color) {
          const hsl = {};
          mat.color.getHSL(hsl);
          mat.color.setHSL(hue, Math.min(0.8, hsl.s + 0.25), hsl.l);
        }
        if (mat.emissive) mat.emissive = mat.emissive.clone();
        child.material = mat;
      });
    }

    function spawnRemotePlayer(id, snapshot) {
      const ghost = makeCar();
      colorizeCar(ghost, hashHue(id));
      ghost.userData.isRemote = true;
      ghost.userData.tailLights?.forEach(({ light }) => { light.intensity = 0.12; });
      scene.add(ghost);
      remotePlayers.set(id, { mesh: ghost, target: null });
      applyRemoteState(id, snapshot || { p: [0, 0, 0], y: 0, s: 0 });
    }

    function removeRemotePlayer(id) {
      const player = remotePlayers.get(id);
      if (!player) return;
      scene.remove(player.mesh);
      player.mesh.traverse((child) => {
        if (child.geometry) child.geometry.dispose?.();
        if (child.material) child.material.dispose?.();
      });
      remotePlayers.delete(id);
    }

    function applyRemoteState(id, state) {
      const player = remotePlayers.get(id);
      if (!player) return;
      const target = {
        position: new THREE.Vector3(state.p?.[0] || 0, state.p?.[1] || 0, state.p?.[2] || 0),
        yaw: state.y || 0,
        speed: state.s || 0,
        steer: state.st || 0,
        brake: Boolean(state.b),
        received: performance.now()
      };
      player.target = target;
    }

    function updateRemotePlayers(dt) {
      const follow = 1 - Math.pow(0.0015, dt);
      for (const player of remotePlayers.values()) {
        if (!player.target) continue;
        player.mesh.position.lerp(player.target.position, follow);
        const currentYaw = player.mesh.rotation.y;
        const deltaYaw = ((player.target.yaw - currentYaw + Math.PI * 3) % (Math.PI * 2)) - Math.PI;
        player.mesh.rotation.y = currentYaw + deltaYaw * follow;
        const rollDelta = (player.target.speed / (player.mesh.userData.wheelRadius || 1)) * dt;
        player.mesh.userData.wheelGroups?.forEach((group) => {
          group.rotation.x -= rollDelta;
        });
        player.mesh.userData.steeringPivots?.forEach((pivot) => {
          pivot.rotation.y = player.target.steer || 0;
        });
        if (player.mesh.userData.tailLights) {
          const active = Boolean(player.target.brake);
          player.mesh.userData.tailLights.forEach(({ light, lens, halo, aura }) => {
            light.intensity = active ? 1.85 : 0.12;
            lens.material.emissiveIntensity = active ? 1.9 : 0.38;
            halo.material.opacity = active ? 0.95 : 0.32;
            halo.scale.setScalar(active ? 0.52 : 0.38);
            aura.material.opacity = active ? 0.55 : 0.0;
            aura.scale.setScalar(active ? 0.88 : 0.72);
          });
        }
      }
    }

    function resolveServerHost() {
      const host = location.hostname;
      if (host === "localhost" || host === "127.0.0.1") return NETWORK.localHost;
      if (!host || host === "") return NETWORK.defaultHost;
      return NETWORK.defaultHost;
    }

    async function checkServerAvailability(host, timeoutMs = 1800) {
      const controller = new AbortController();
      const timer = setTimeout(() => controller.abort(), timeoutMs);
      const protocol = host.includes("localhost") || host.includes("127.0.0.1") ? "http" : "https";
      try {
        const res = await fetch(`${protocol}://${host}/health`, {
          signal: controller.signal,
          cache: "no-store"
        });
        return res.ok;
      } catch (err) {
        return false;
      } finally {
        clearTimeout(timer);
      }
    }

    function cleanSocket() {
      if (NETWORK.socket) {
        NETWORK.socket.close();
        NETWORK.socket = null;
      }
    }

    function scheduleReconnect() {
      if (NETWORK.reconnectTimer) return;
      NETWORK.reconnectTimer = setTimeout(() => {
        NETWORK.reconnectTimer = null;
        initNetwork();
      }, 2500);
    }

    function sendStateSnapshot() {
      if (!NETWORK.socket || NETWORK.socket.readyState !== WebSocket.OPEN) return;
      const now = performance.now();
      if (now - NETWORK.lastSend < 50) return; // ~20 Hz
      NETWORK.lastSend = now;
      const payload = {
        type: "state",
        state: {
          p: [Number(car.position.x.toFixed(3)), Number(car.position.y.toFixed(3)), Number(car.position.z.toFixed(3))],
          y: Number(state.yaw.toFixed(4)),
          s: Number(state.speed.toFixed(3)),
          st: Number(state.steer.toFixed(4)),
          b: Boolean(state.brakeActive)
        }
      };
      NETWORK.socket.send(JSON.stringify(payload));
    }

    function handleMessage(evt) {
      let data;
      try {
        data = JSON.parse(evt.data);
      } catch (err) {
        return;
      }

      if (data.type === "hello") {
        NETWORK.id = data.id;
        setNetStatus(`Online: ${resolveServerHost()}`, true);
        if (Array.isArray(data.players)) {
          data.players.forEach((p) => {
            if (!remotePlayers.has(p.id)) spawnRemotePlayer(p.id, p.state);
            else applyRemoteState(p.id, p.state);
          });
        }
        sendStateSnapshot();
      } else if (data.type === "state" && data.id && data.id !== NETWORK.id) {
        if (!remotePlayers.has(data.id)) spawnRemotePlayer(data.id, data.state);
        else applyRemoteState(data.id, data.state);
      } else if (data.type === "player-left" && data.id) {
        removeRemotePlayer(data.id);
      } else if (data.type === "player-joined" && data.id && data.id !== NETWORK.id) {
        if (!remotePlayers.has(data.id)) spawnRemotePlayer(data.id, { p: [0, 0, 0], y: 0, s: 0 });
      }
    }

    async function initNetwork() {
      cleanSocket();
      const host = resolveServerHost();
      const available = await checkServerAvailability(host);
      if (!available) {
        NETWORK.mode = "offline";
        setNetStatus("Offline режим (сервер недоступен)", false);
        scheduleReconnect();
        return;
      }

      const protocol = host.includes("localhost") || host.includes("127.0.0.1") ? "ws" : "wss";
      const ws = new WebSocket(`${protocol}://${host}/ws`);
      ws.addEventListener("open", () => {
        NETWORK.socket = ws;
        NETWORK.mode = "online";
        NETWORK.lastSend = 0;
        setNetStatus(`Online: ${host}`, true);
        sendStateSnapshot();
      });
      ws.addEventListener("message", handleMessage);
      ws.addEventListener("close", () => {
        NETWORK.mode = "offline";
        setNetStatus("Offline режим (нет соединения)", false);
        NETWORK.socket = null;
        scheduleReconnect();
      });
      ws.addEventListener("error", () => {
        setNetStatus("Offline режим (ошибка связи)", false);
      });
    }

    // --- Input: single joystick + keyboard fallback ---
    const joy = document.getElementById("joy");
    const nub = document.getElementById("joyNub");
    const isCoarsePointer = window.matchMedia("(pointer: coarse)").matches;
    if (!isCoarsePointer) {
      joy.style.display = "none";
    }

    let joyActive = false;
    let joyPointerId = null;
    let joyX = 0;  // -1..1
    let joyY = 0;  // -1..1

    function setNub(dx, dy) {
      nub.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
    }

    function handleJoyEvent(e) {
      e.preventDefault();
      const rect = joy.getBoundingClientRect();
      const cx = rect.left + rect.width / 2;
      const cy = rect.top + rect.height / 2;
      const radius = rect.width * 0.36; // nub travel

      const px = e.clientX;
      const py = e.clientY;

      let dx = px - cx;
      let dy = py - cy;

      const len = Math.hypot(dx, dy);
      if (len > radius) {
        dx = (dx / len) * radius;
        dy = (dy / len) * radius;
      }

      setNub(dx, dy);

      // Normalize to -1..1. Up on screen = forward throttle.
      joyX = dx / radius;
      joyY = -dy / radius;

      // Deadzone (so it doesn't drift)
      const dz = 0.08;
      if (Math.abs(joyX) < dz) joyX = 0;
      if (Math.abs(joyY) < dz) joyY = 0;
    }

    joy.addEventListener("pointerdown", (e) => {
      joyActive = true;
      joyPointerId = e.pointerId;
      joy.setPointerCapture(joyPointerId);
      handleJoyEvent(e);
    }, { passive: false });

    joy.addEventListener("pointermove", (e) => {
      if (!joyActive || e.pointerId !== joyPointerId) return;
      handleJoyEvent(e);
    }, { passive: false });

    function releaseJoy() {
      joyActive = false;
      joyPointerId = null;
      joyX = 0;
      joyY = 0;
      setNub(0, 0);
    }

    joy.addEventListener("pointerup", (e) => {
      if (e.pointerId !== joyPointerId) return;
      releaseJoy();
    }, { passive: false });

    joy.addEventListener("pointercancel", releaseJoy, { passive: false });

    // Keyboard fallback (PC)
    const keys = new Set();
    window.addEventListener("keydown", (e) => { keys.add(e.code); });
    window.addEventListener("keyup", (e) => { keys.delete(e.code); });

    function keyboardAxes() {
      let x = 0, y = 0;
      const left  = keys.has("ArrowLeft") || keys.has("KeyA");
      const right = keys.has("ArrowRight")|| keys.has("KeyD");
      const up    = keys.has("ArrowUp")   || keys.has("KeyW");
      const down  = keys.has("ArrowDown") || keys.has("KeyS");
      if (left) x -= 1;
      if (right) x += 1;
      if (up) y += 1;
      if (down) y -= 1;
      return { x, y };
    }

    // --- Simple driving ---
    const state = {
      speed: 0,
      yaw: 0,
      steer: 0,
      brakeActive: false
    };

    let inputX = 0;
    let inputY = 0;

    const MAX_FWD = 18.0;
    const MAX_REV = 9.0;
    const ACCEL = 26.0;   // units/s^2
    const DRAG = 6.0;     // slows down when no throttle
    const TURN = 2.2;     // radians/sec at full steer (scaled by speed)

    const bounds = 95; // map half-size clamp

    // Camera follow (portrait-friendly)
    const camOffset = new THREE.Vector3(0, 6.0, -12.0);
    const camLookAhead = new THREE.Vector3(0, 1.2, 6.5);

    function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }
    function approach(current, target, maxDelta) {
      const delta = target - current;
      if (Math.abs(delta) <= maxDelta) return target;
      return current + Math.sign(delta) * maxDelta;
    }

    let last = performance.now();
    function tick(now) {
      const dt = Math.min((now - last) / 1000, 0.033);
      last = now;

      // Prefer joystick; if idle, use keyboard.
      let ax = joyX;
      let ay = joyY;
      if ((!joyActive || !isCoarsePointer) && ax === 0 && ay === 0) {
        const k = keyboardAxes();
        ax = k.x;
        ay = k.y;
      }

      // Smooth input so key presses feel gentle on desktop.
      const INPUT_ACCEL = 5.0;
      inputX = approach(inputX, ax, INPUT_ACCEL * dt);
      inputY = approach(inputY, ay, INPUT_ACCEL * dt);
      ax = inputX;
      ay = inputY;

      // Target speed from throttle (ay)
      let targetSpeed = 0;
      if (ay > 0) targetSpeed = ay * MAX_FWD;
      else if (ay < 0) targetSpeed = ay * MAX_REV; // negative

      // Accel towards target, otherwise drag
      if (targetSpeed !== 0) {
        state.speed = approach(state.speed, targetSpeed, ACCEL * dt);
      } else {
        state.speed = approach(state.speed, 0, DRAG * dt);
      }

      // Turning scales with speed (no rotation while stopped)
      const speedFactor = clamp(Math.abs(state.speed) / MAX_FWD, 0, 1);
      const steer = state.speed < -0.05 ? -ax : ax;
      const turnRate = -steer * TURN * speedFactor;
      state.yaw += turnRate * dt;

      const visualSteer = -clamp(ax, -1, 1) * (Math.PI / 7);
      state.steer = visualSteer;
      car.userData.steeringPivots?.forEach((pivot) => {
        pivot.rotation.y = visualSteer;
      });

      car.rotation.y = state.yaw;

      // Move forward in car's local +Z
      const forward = new THREE.Vector3(0, 0, 1).applyEuler(car.rotation);
      car.position.addScaledVector(forward, state.speed * dt);

      const rollDelta = (state.speed / (car.userData.wheelRadius || 1)) * dt;
      car.userData.wheelGroups?.forEach((group) => {
        group.rotation.x -= rollDelta;
      });

      // Clamp to bounds (soft wall)
      car.position.x = clamp(car.position.x, -bounds, bounds);
      car.position.z = clamp(car.position.z, -bounds, bounds);
      car.position.y = 0;

      // Camera follow
      const offset = camOffset.clone().applyEuler(car.rotation);
      const desiredCam = car.position.clone().add(offset);
      camera.position.lerp(desiredCam, 1 - Math.pow(0.001, dt)); // smooth

      // Reset up before lookAt so roll never leaks into the base orientation.
      camera.up.set(0, 1, 0);
      const look = camLookAhead.clone().applyEuler(car.rotation).add(car.position);
      camera.lookAt(look);

      const braking = state.speed > 0.2 && targetSpeed < state.speed - 0.12;
      const reversing = state.speed < -0.15;
      state.brakeActive = braking || reversing;
      if (car.userData.tailLights) {
        car.userData.tailLights.forEach(({ light, lens, halo, aura }) => {
          light.intensity = state.brakeActive ? 1.85 : 0.12;
          lens.material.emissiveIntensity = state.brakeActive ? 1.9 : 0.38;
          halo.material.opacity = state.brakeActive ? 0.95 : 0.32;
          halo.scale.setScalar(state.brakeActive ? 0.52 : 0.38);
          aura.material.opacity = state.brakeActive ? 0.55 : 0.0;
          aura.scale.setScalar(state.brakeActive ? 0.88 : 0.72);
        });
      }

      updateRemotePlayers(dt);

      if (NETWORK.mode === "online") {
        sendStateSnapshot();
      }

      renderer.render(scene, camera);
      requestAnimationFrame(tick);
    }
    initNetwork();
    requestAnimationFrame(tick);

    // Resize
    function onResize() {
      renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
      renderer.setSize(window.innerWidth, window.innerHeight);
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
    }
    window.addEventListener("resize", onResize);
    window.addEventListener("orientationchange", onResize);
    onResize();
  </script>
</body>
</html>
